# CLAUDE.md: ЛУЧШИЕ ПРАКТИКИ НАПИСАНИЯ SHELL-СКРИПТОВ (BASH)

**ВАЖНОЕ ПРИМЕЧАНИЕ ДЛЯ LLM:** Следуйте этим правилам, чтобы генерировать безопасные, предсказуемые и поддерживаемые Bash-скрипты. **ЛЮБОЕ ОТКЛОНЕНИЕ ОТ ПРАВИЛ БЕЗОПАСНОСТИ (ОСОБЕННО ИСПОЛЬЗОВАНИЕ `eval` ИЛИ НЕКВОТИРОВАНИЕ ПЕРЕМЕННЫХ) ЗАПРЕЩЕНО.**

**При написании проекта использовать лучшие практики разработки на Shell, с фокусом на низкую когнитивную сложность, соблюдение принципа DRY и обеспечение чистоты кода.**

## 0. Важные вводные
**Используй линтер ShellCheck** - проверяй код при помощи линтера
**Определяй коды выхода в начале файла** - return - для функций, exit - для всего скрипта
**Используй стандартизированные методы возврата** - return - для функций, exit - для всего скрипта
**Вывод данных делайте в stdout, ошибки - в stderr (>&2)**
**В начале файла определять глобальные exit коды** - и полльзоваться определеннми ранее кодами во всем файле
**Внутри функций всегда использовать return вместо exit** - в конце файла использовать case блок для установки exit кода
**Заголовки файлов**
```bash
#!/bin/bash
#
# SCRIPT TYPE: [MAIN|MODULE|HYBRID]
# RETURN METHOD: [EXIT|RETURN|AUTO]
# DESCRIPTION: [краткое описание]
#
# MAIN: Использует exit, вызывается напрямую
# MODULE: Использует return, подключается через source
# HYBRID: Может работать в обоих режимах
#
```

## 1. Настройка окружения и безопасность (Обязательные требования)

**ВЫ ДОЛЖНЫ** начинать все исполняемые скрипты с явного указания интерпретатора.

1.  **Интерпретатор:** Используйте `bash` и указывайте его через `env` для лучшей портативности:
    ```bash
    #!/usr/bin/env bash
    ```
    (Исключение: если требуется строгая совместимость с `sh` или определенная среда, требующая `/bin/bash`).

2.  **Режимы безопасности (CRITICAL):** **ВЫ ДОЛЖНЫ** установить следующие три опции в начале скрипта для обеспечения безопасности и предсказуемости:
    ```bash
    set -euo pipefail
    ```

3.  **Логирование и отладка:** Если требуется отладка, включите трассировку (`xtrace`) через проверку переменной окружения `TRACE`:
    ```bash
    if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi
    ```

## 2. Именование, цитирование и переменные

1.  **Использование `local`:** **ВЫ ДОЛЖНЫ** объявлять все переменные внутри функций как локальные (`local`), чтобы избежать загрязнения глобального пространства имен:
    ```bash
    my_func () {
        local count=0 # Правильно: переменная локальна
    }
    ```

2.  **Квотирование (CRITICAL):** **ВЫ ДОЛЖНЫ** всегда заключать в двойные кавычки (`"$VARNAME"`) все переменные, которые подвергаются расширению, чтобы предотвратить разделение слов и расширение шаблонов (глоббинг).
    ```bash
    # Неправильно: может вызвать проблемы, если $file содержит пробелы
    cp $file $destination
    # Правильно: безопасно
    cp "$file" "$destination"
    ```

3.  **Одинарные кавычки:** Используйте одинарные кавычки (`'string'`), когда переменные не должны расширяться (например, для литеральных строк).
    ```bash
    message='You are $USER' # $USER не будет расширен
    ```

4.  **Синтаксис команд:** Используйте `$(command)` для подстановки команд вместо обратных кавычек (`` `command` ``), так как это более читаемо и лучше для вложенности.
    ```bash
    var="$(date)" # Правильно
    # var=`date` # Неправильно
    ```

5.  **Имена переменных:** Используйте описательные имена переменных в нижнем регистре с подчеркиванием (например, `user_count`, `backup_file`). Избегайте заглавных букв, если это не константы, экспортируемые переменные или системные переменные.

## 3. Структура кода и функции

1.  **Функции:** Структурируйте скрипт, разбивая задачи на четкие, небольшие функции с описательными именами. Избегайте использования ключевого слова `function`.
    ```bash
    cleanup_temp_files () { # Предпочтительный синтаксис
        # ...
    }
    ```

2.  **Комментарии:** Предоставляйте подробные комментарии для нетривиальных участков кода. В библиотечных функциях или сложных функциях **ВЫ ДОЛЖНЫ** включать заголовок функции, описывающий ее назначение, глобальные переменные, аргументы и возвращаемые значения.

3.  **Функция `main`:** Для скриптов, содержащих более одной функции, используйте функцию `main` для основной логики и вызывайте ее в конце:
    ```bash
    main () {
        # Основная логика
        echo "Doing awesome stuff"
    }
    main "$@"
    ```

4.  **Сообщения об ошибках:** Все сообщения об ошибках **ВЫ ДОЛЖНЫ** перенаправлять в `STDERR` (`>&2`):
    ```bash
    echo "ERROR: File $file not found." >&2
    ```

## 4. Управляющие конструкции и операторы

1.  **Условия:** Используйте встроенный оператор `[[ ... ]]` для условного тестирования вместо `[ ... ]` или `test`.
    ```bash
    if [[ -d "/etc" ]]; then ... fi
    ```
    **ВАЖНО:** Для сравнения строк используйте `==`, а не `=`.

2.  **Арифметика:** Используйте `((...))` или `$((...))` для математических операций и сравнений целых чисел. Избегайте команд `let` или `expr`.
    ```bash
    a=5; b=4
    if (( a > b )); then ... fi # Арифметическое сравнение
    result=$(( a + b ))        # Вычисление
    ```

3.  **Форматирование управляющих структур:** Размещайте `; then` и `; do` на той же строке, что и `if`, `while` или `for`:
    ```bash
    if [[ true ]]; then
        echo "true"
    fi
    ```

4.  **Итерация по данным:** Избегайте разбора вывода `ls(1)`. Для потоковой обработки данных, разделенных символами новой строки, используйте конструкцию `while read -r` вместо циклов `for` по неквотированным переменным:
    ```bash
    # Правильно для потоковой обработки
    while IFS=: read -r user _ ; do
        echo "User is $user"
    done < /etc/passwd
    ```

5.  **Избегайте Useless Use of Cat (UUOC):** Используйте перенаправление ввода (`<`) вместо конвейера, если это возможно, чтобы избежать ненужного вызова `cat`:
    ```bash
    grep foo < file # Правильно
    # cat file | grep foo # Неправильно
    ```

## 5. Запрещенные практики (YOU MUST NOT)

1.  **`eval`:** **ВЫ ДОЛЖНЫ ИЗБЕГАТЬ** использования команды `eval` при любых обстоятельствах из-за рисков внедрения кода и затруднения статического анализа.

2.  **`set -e` Caveat:** Избегайте использования `set -e` там, где команда может заведомо завершиться неудачей. В таких случаях **ВЫ ДОЛЖНЫ** явно проверять код возврата или использовать `|| true`.

3.  **Алиасы:** Не используйте алиасы в скриптах; используйте функции.

4.  **GNU-специфичные опции:** При вызове внешних команд (`awk`, `sed`, `grep`) избегайте опций, специфичных для GNU, если только не требуется максимальная портативность.

5.  **SUID/SGID:** Не используйте SUID и SGID в Shell-скриптах.

## 6. Рекомендации по рабочему процессу (для LLM)

При написании или рефакторинге кода на Shell, LLM **СЛЕДУЕТ** придерживаться следующих стратегий, основанных на лучших практиках LLM-кодирования:

1.  **Исследование и планирование:** Прежде чем писать код для сложной задачи, **СЛЕДУЕТ** составить план действий. Используйте команду/режим `think` (или `think hard`/`ultrathink`) для более тщательной оценки альтернатив и шагов реализации.
2.  **TDD (Test-Driven Development):** Если задача легко проверяется, сначала напишите тесты, которые заведомо провалятся, а затем итеративно пишите код, чтобы эти тесты прошли.
3.  **Итеративность:** Ожидайте, что решение не будет идеальным с первой попытки. Продолжайте итерации, используя предоставленные цели (тесты, скриншоты или ожидаемый вывод) до достижения успеха.
4.  **Специфичность:** Инструкции должны быть максимально специфичными. Чем четче сформулировано намерение, тем лучше результат. Избегайте двусмысленных запросов.
5.  **Контрольный список:** Для очень больших задач (например, миграция кода, исправление множества ошибок линтера) используйте Markdown-файл в качестве рабочего поля/скретчпада, чтобы создать контрольный список и отмечать выполненные шаги один за другим.
