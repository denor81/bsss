#!/usr/bin/env bash
# Изменяет SSH порт
# MODULE_TYPE: modify

set -Eeuo pipefail

readonly MODULES_DIR_PATH="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")" )" && pwd)"
readonly CURRENT_MODULE_NAME="$(basename "$0")"

source "${MODULES_DIR_PATH}/../lib/vars.conf"
source "${MODULES_DIR_PATH}/../lib/logging.sh"
source "${MODULES_DIR_PATH}/../lib/user_confirmation.sh"
source "${MODULES_DIR_PATH}/common-helpers.sh"

dispatch_logic() {
    local raw_paths

    raw_paths=$(get_paths_by_mask "$SSH_CONFIGD_DIR" "$BSSS_SSH_CONFIG_FILE_MASK" | tr '\0' '\n' )

    if [[ -z "$raw_paths" ]]; then
        bsss_config_not_exists
    else
        bsss_config_exists "$raw_paths"
    fi
}

bsss_config_not_exists() {
    action_install_port "" "1" || return "$?"
}

action_install_port() {
    local raw_paths="${1:-}"
    local create_only="${2:-0}"
    local suggested_port
    local new_port
    local port_pattern="^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"

    suggested_port=$(get_free_random_port) || return "$?"
    new_port=$(ask_value "Введите новый порт" "$suggested_port" "$port_pattern" "1-65535, Enter для $suggested_port") || return "$?"

    if is_port_busy "$new_port"; then
        log_error "Порт $new_port уже занят другим сервисом."
        action_install_port "$raw_paths" "" || return "$?"
        return "$?" # Возвращаю код если будет несколько итераций
    fi

    (( create_only == 0 )) && delete_paths "$raw_paths"
    create_new_ssh_config_file "$new_port" || return "$?"
    actions_after_port_set || return "$?"
}

branch_bsss_exists() {
    local raw_paths="$1"
    local user_action
    local -a paths=()

    mapfile -t paths < <(printf '%s' "$raw_paths")

    log_info "Найдены правила ${UTIL_NAME^^}:"

    for path in "${paths[@]}"; do
        log_info_simple_tab "Путь: $path"
    done

    log_info_simple_tab "1. Сброс (удаление правила ${UTIL_NAME^^})"
    log_info_simple_tab "2. Переустановка (замена на новый порт)"

    user_action=$(_ask_value "Выберите" "" "^[12]$" "1/2") || return "$?"

    case "$user_action" in
        1) action_restore_default "$raw_paths" ;;
        2) action_install_port "$raw_paths" "" ;;
    esac
}

actions_after_port_set() {
    # sleep 0.2
    restart_services
    validate_ssh_ports
    # check_config_ports "$SSH_CONFIG_FILE" "$SSH_CONFIG_FILE_MASK" "SSH" # Проверка SSH портов во всех файлах
    # check_config_ports "" "$BSSS_SSH_CONFIG_FILE_MASK" "$UTIL_NAME" # Проверка BSSS правил
}

action_restore_default() {
    local raw_paths="$1"

    delete_paths "$raw_paths"
    actions_after_port_set
}



restart_services() {
    if sshd -t; then
        systemctl daemon-reload && log_info "Конфигурация перезагружена [systemctl daemon-reload]"
        systemctl restart ssh && log_info "SSH сервис перезагружен [systemctl restart ssh]"
    else
        log_error "Ошибка конфигурации ssh [sshd -t]"
        return 1
    fi
}

is_port_busy() {
    ss -ltn | grep -qE ":$1([[:space:]]|$)"
}

get_free_random_port() {
    local port
    while true; do
        port=$(shuf -i 10000-65535 -n 1)
        if ! is_port_busy "$port"; then
            printf '%s' "$port"
            return 0 # для выхода из цикла
        fi
    done
}

# Создание нового конфигурационного файла
create_new_ssh_config_file() {
    local port="$1"
    local path="$SSH_CONFIGD_DIR/$BSSS_SSH_CONFIG_FILE_NAME"
    
    if [[ -z "$port" ]]; then
        log_error "Не указан порт для конфигурационного файла"
        return 1
    fi
    
    # Создаем файл с настройкой порта
    if cat > "$path" << EOF
# Generated by "${UTIL_NAME^^}"
# SSH port configuration
Port $port
EOF
    then
        log_info "Правило создано [Port $port]: $path"
    else
        log_error "Не удалось создать правило: $path"
        return 1
    fi
}

main() {
    dispatch_logic
}

# (Guard): Выполнять main ТОЛЬКО если скрипт запущен, а не импортирован
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
