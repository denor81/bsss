# Манифест проектирования: Bash-инженерия 2026

1. Фундаментальная философия
 - Данный проект — это не «скрипт», это модульный фреймворк на базе Unix-утилит. Мы не пишем императивный код, мы проектируем потоки данных.
  - Bash как клей: Мы используем Bash для управления процессами и файловыми дескрипторами. Вся тяжелая работа (парсинг, трансформация) делегируется специализированным инструментам: gawk (GNU Awk), sed, grep, xargs, ss.
 - Изоляция побочных эффектов: Каждая значимая модификация системы должна быть атомарной.
 - Потоковая архитектура (Pipeline-first): Данные «текут» через пайпы. Минимизируй использование переменных для хранения контента. Используй дескрипторы файлов и NUL-разделители (\0) для передачи путей и списков.

2. Золотой стандарт потоков (IO)
 - NUL-разделитель (\0): Единственный надежный способ передачи данных в пайплайнах. Пути к файлам, списки портов и любые массивы данных передаются через \0.
 - Догма: «NUL живет в трубе, но умирает в переменной».
 - Чистота FD 1 (stdout): Только чистые данные для следующего звена.
 - Диагностика FD 2 (stderr): Все логи, интерфейсы, подтверждения и интерактив — строго в stderr. (Используй систему логирования проекта - log_info, log_error и прочие в logging.sh, для подтверждения действия используй - io::confirm_action в user_confirmation.sh, для выбора значения io::ask_value там же.)
 - Запрет на eval: Никогда не использовать eval для выполнения строк, полученных из парсинга. Используй массивы, xargs или прямой вызов.
 - Разделение потоков (FD 0, 1, 2): stdout (FD 1) — строго чистые данные для следующего звена. stderr (FD 2) — интерфейс, логирование (log_info), диагностика и интерактив.

3. Архитектура ролей (Namespacing)
 - Функции обязаны иметь префиксы для обозначения своей зоны ответственности:
   - orchestrator:: — высокоуровневая логика и переключение сценариев.
   - ssh::, ufw::, grub:: и т.д. — специфичные провайдеры (библиотеки) для сервисов.
   - io:: — взаимодействие с пользователем и логирование.
   - sys:: — низкоуровневые системные проверки (порты, файлы, процессы).
 - Никаких монолитов. Одна функция — одна атомарная задача.

  4. Контракт функции (Аннотации)
   - Перед каждой функцией обязательна аннотация:
```bash
# @type:        Source | Filter | Transformer | Orchestrator | Sink | UNDEFINED
# @description: Краткое описание физики действия
# @stdin:       Формат входящих данных (например, NUL-separated paths (path\0))
# @stdout:      Формат выходящих данных
# @exit_code:   0 - успех
#               2 - намеренная отмена пользователем (SIGINT-like)
#               >0 - ошибка (кроме 2)
```

   - Стандарт обработки статусов BSSS:
     * Модули обязаны возвращать 0 при успехе и 2 при намеренной отмене пользователем.
     * Диспетчер (Runner) обязан интерпретировать код 2 как информационный сигнал SIGINT-like, не прерывая цикл работы.
     * Любой другой код > 0 (кроме 2) интерпретируется как CRITICAL ошибка.

  4.1. Коды возврата BSSS
   - Система использует стандартизированные коды возврата для обозначения состояний:
     
     | Код | Описание | Категория | Обработка в Runner |
     |-----|----------|-----------|-------------------|
     | 0 | Успешное завершение | SUCCESS | Информационное сообщение |
     | 2 | Намеренная отмена пользователем | INFO | Информационное сообщение, продолжение цикла |
     | 3 | Завершение через механизм rollback (watchdog) | INFO | Информационное сообщение, продолжение цикла |
     | 4 | Требуется предварительная настройка | INFO | Информационное сообщение, продолжение цикла |
     | 130 | Прерывание по Ctrl+C | INFO | Эквивалент кода 2 |
     | 1, >4 | Критическая ошибка | CRITICAL | Ошибка с логированием пути к модулю |

   - Информационные коды (2, 3, 4, 130) не прерывают основной цикл модификации
   - Коды возврата документируются в контракте функции (@exit_code)
   - Используйте код 4 когда модуль требует предварительных условий для выполнения

  5. Инструментарий
  - Критическая зависимость: gawk (GNU Awk)
    * Проверка наличия: sys::gawk::check_dependency (вызывается в main.sh)
    * Обязательное использование: Все вызовы awk должны быть явно указаны как gawk
    * Причина: Проект использует NUL-разделители (\0), которые корректно поддерживает только GNU Awk
    * Синтаксис: Используется синтаксис gawk (например, ORS="\0", RS='\0', match() с массивами)
 - Использование read -r -d ''.
 - Использование mapfile -d ''.
 - Использование sort -z, xargs -0.
 - Использование современных стандартов GNU Coreutils (mapfile -d '', read -d '', sort -z, gawk ORS="\0").
 - Конвенция путей: Все пути из vars.conf задаются БЕЗ завершающего и начального слеша. Не используйте ${var%/} для переменных из vars.conf (за исключением динамически получаемых параметров функций).

6. Архитектурные принципы 2026 года
 - Идемпотентность: Повторный запуск скрипта не ломает систему. Используй маркеры # Generated by BSSS.
 - Выживаемость (Watchdog): Критические изменения (SSH) защищаются фоновыми процессами-сторожами (nohup, sleep в фоне, trap по сигналам SIGUSR1).
 - Безопасность: ПОЛНЫЙ ЗАПРЕТ использования eval. Строгая валидация ввода через регулярные выражения.
 - Робастность: Пайплайны должны завершаться с кодом 0. Используй || true для tail -f или специфические awk-фильтры для обработки сигналов SIGPIPE (141) и завершающих маркеров (EOF).

7. Карта функций и переиспользование кода
 - function_map.txt содержит полный перечень всех функций проекта с их типами, описанием и расположением.
 - Формат: ID | функция() | тип | описание | путь_к_файлу
 - Использование карты функций:
   * Перед написанием нового функционала всегда проверяйте function_map.txt на наличие существующих решений
   * Ищите функции по ключевым словам в описании или по префиксам имен (ssh::, ufw::, sys:: и т.д.)
   * Используйте функции из существующих модулей для построения пайплайнов обработки данных
 - Размещение хелперов:
   * Общие хелперы (используемые в нескольких несвязанных модулях) → modules/common-helpers.sh
   * Специфичные хелперы (используемые только в одном типе модулей) → соответствующий файл модуля
     * SSH-хелперы → modules/04-ssh-port-helpers.sh
     * UFW-хелперы → modules/04-ssh-port-helpers.sh
     * Другие доменные хелперы → modules/[domain]-helpers.sh
 - Принципы переиспользования:
   * Предпочитайте композицию функций через пайплайны созданию дублирующего кода
   * Соблюдайте контракты функций (stdin/stdout/exit_code) при построении пайплайнов
   * Используйте префиксы имен функций для быстрого поиска в карте функций

 8. Типы функций и их назначение
 - Source (Источник): Генерирует поток (например, get_paths через printf %s\0).
 - Filter/Transformer (Фильтр): Принимает stdin, отдает stdout (предпочтение gawk, sed, grep, xargs -0).
 - Validator/Orchestrator (Диспетчер): Принимает решения, управляет логикой запуска других функций.
 - Sink: Потребляет поток данных, не передает дальше (например, запись в файл, выполнение команды).

9. Примеры
 - Оркестрация
```bash
# @type:        Orchestrator
# @description: Обработчик сценария отсутствия конфигурации SSH
#               Установка нового порта SSH и добавление правила в UFW
# @params:      нет
# @stdin:       нет
# @stdout:      нет
# @exit_code:   0 — упешно
#               $? — код ошибки дочернего процесса
ssh::orchestrator::config_not_exists() {
    ssh::ui::get_new_port | ssh::rule::reset_and_pass | ufw::rule::reset_and_pass | ssh::port::install_new
    ssh::orchestrator::log_statuses
}
```
 - Фильтр
```bash
# @type:        Filter
# @description: Удаляет все правила UFW BSSS и передает порт дальше
# @params:      нет
# @stdin:       port\0 (опционально)
# @stdout:      port\0 (опционально)
# @exit_code:   0 - успешно
ufw::rule::reset_and_pass() {
    local port=""

    # || true нужен что бы гасить код 1 при false кода [[ ! -t 0 ]]
    [[ ! -t 0 ]] && IFS= read -r -d '' port || true
    
    ufw::rule::delete_all_bsss

    # || true нужен что бы гасить код 1 при false кода [[ -n "$port" ]]
    [[ -n "$port" ]] && printf '%s\0' "$port" || true
}
```
 - Источник
```bash
# @type:        Source
# @description: Генерирует случайный свободный порт в диапазоне 10000-65535
# @params:      нет
# @stdin:       нет
# @stdout:      port
# @exit_code:   0 - порт успешно сгенерирован
#               $? - ошибка
ssh::port::generate_free_random_port() {
    while IFS= read -r port || break; do
        if ! ssh::port::is_port_free "$port"; then
            printf '%s\n' "$port"
            return
        fi
    done < <(shuf -i 10000-65535)
}
```
  - Дополнительные примеры
    - [modules/04-ssh-port-helpers.sh](modules/04-ssh-port-helpers.sh)
    - [modules/04-ssh-port-modify.sh](modules/04-ssh-port-modify.sh)
    - [main.sh](main.sh)

 10. Инструменты разработки и команды
 - Генерация карты функций: `./utils/generate_function_map.sh` — обновляет function_map.txt с актуальными контрактами всех функций
 - Линтинг: Используй shellcheck для проверки кода (при наличии)
 - Форматирование: При необходимости используй shfmt для согласования отступов
  - Запуск основного скрипта: `./main.sh` для локального тестирования
 - Запуск модуля напрямую: `bash modules/04-ssh-port-helpers.sh` для тестирования отдельных компонентов
 - Активация строгого режима: `set -Eeuo pipefail` в начале каждого скрипта (E=exit on error, e=exit on undefined var, u=pipefail)

  11. Конвенции стиля кода
  - Shebang: Обязательное `#!/usr/bin/env bash` в начале всех bash-файлов
  - Отступы: Используй пробелы (не табы), стандартный отступ — 4 пробела
  - Переменные: readonly для констант (определяются в lib/vars.conf), local для временных переменных внутри функций
  - Путь к корню проекта: `${PROJECT_ROOT}` — должен быть определен как `readonly PROJECT_ROOT="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")" )" && pwd)"`
  - Имя текущего модуля: `${CURRENT_MODULE_NAME}` — используется в логировании
  - Комментарии shellcheck: Используй `# shellcheck disable=SCCODE` только при обоснованной необходимости
  - Использование gawk: Все вызовы awk должны быть явно указаны как gawk. Никогда не используйте просто awk
  - Идемпотентность: Каждая операция должна быть идемпотентной. Используй маркеры "# Generated by BSSS" для идентификации сгенерированных файлов
  - Валидация входных данных: Строгая проверка через регулярные выражения (пример: `"^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"` для портов)

  12. Философия обучения и разработки
  - Лаконичность и «физика»: Объясняй решения через работу ядра, системные вызовы (fork, exec), буферы труб и дескрипторы файлов.
  - Критический аудит: Если видишь возврат к императивному стилю (массивы там, где нужен поток), мягко возвращай к «поточной» архитектуре.
  - Инструментарий 2026: Используй современные стандарты GNU Coreutils (mapfile -d '', read -d '', sort -z, gawk ORS="\0").
  - Текущее состояние проекта: Мы разработали модульный фреймворк для настройки системных параметров (на примере SSH). Реализована динамическая система обнаружения модулей по типам (check, modify, helper) с использованием метаданных в заголовках файлов. Система построена на базе «Умных источников» и «Диспетчеров», которые управляют логикой установки и сброса конфигураций.

  13. Стандарт нейминга функций
   - Фундаментальные принципы:
     * Иерархия: domain::subdomain::action (максимум 3 уровня)
     * Субдомены обязательны для всех функций кроме самых простых
     * Читаемость превыше краткости

   - Правила для action:
     * Дублирование ДОПУСТИМО, если:
       - Без него теряется смысл: ssh::port::generate_free_random_port (не generate_free_random)
       - Повышает однозначность: ssh::port::is_port_free (лучше чем is_busy)
       - Существительное — важная часть действия
     * Дублирование НЕ обязательно, если:
       - Субдомен уже однозначно указывает объект: ufw::ping::is_configured (не is_ping_configured)
       - Действие очевидно из контекста

   - Примеры нейминга:
     * Оркестраторы: ssh::ssh::orchestrator::log_statuses, ufw::orchestrator::run_module

   14. I18n (Internationalization)
    - Подробная документация: [lib/i18n/README.md](lib/i18n/README.md)

    - Архитектура:
      * Использует ассоциативные массивы Bash 4+ для переводов
      * Файловая структура: lib/i18n/{ru|en}/domain.sh
      * Переключение языка через файл .lang в корне проекта

    - Использование:
      * Основная функция: `_ "message_key"` или `i18n::get "message_key"`
      * В функциях логирования: `log_info "message_key" "arg1" "arg2"`
      * Все логеры сами вызывают `_()` для перевода, не нужно вызывать явно

    - Конвенции именования ключей:
      * Формат: module.submodule.action.message_type
      * Примеры:
        - `common.error_root_privileges` - общие ошибки
        - `ssh.ui.get_action_choice.available_actions` - UI сообщения SSH модуля
        - `ufw.status.enabled` - статусы UFW

    - Динамические данные в переводах:
      * Все динамические данные передаются как аргументы через `%s` плейсхолдеры
      * НЕ ЗАШИВАЙТЕ динамические значения в переводы!

      **ПРАВИЛЬНО (номер меню как аргумент):**
      ```bash
      # lib/i18n/ru/common.sh
      I18N_MESSAGES["common.info_menu_item_format"]="%s. %s"
      I18N_MESSAGES["ssh.menu.item_exit"]="%s. Выход"

      # modules/helpers/ssh-port.sh
      log_info_simple_tab "ssh.menu.item_exit" "0"           # 0. Выход
      log_info_simple_tab "common.info_menu_item_format" "1" "Текст"  # 1. Текст
      ```

      **НЕПРАВИЛЬНО (номер зашит в перевод):**
      ```bash
      # lib/i18n/ru/common.sh
      I18N_MESSAGES["ssh.menu.item_exit"]="0. Выход"    # ОШИБКА!
      ```

    - Заглушка `no_translate`:
      * Используется для вывода текста без перевода (пути к файлам, динамические строки)
      * Определена в common.sh: `I18N_MESSAGES["no_translate"]="%s"`
      * Примеры использования:

      ```bash
      # Путь к файлу
      log_info_simple_tab "no_translate" "/etc/ssh/sshd_config:Port 22"

      # Динамически сформированная строка
      local menu_text="$id. $action"
      log_info_simple_tab "no_translate" "$menu_text"
      ```

    - Валидное использование `_()` и `i18n::get()`:
      * ТОЛЬКО в контексте IO функций (пользовательский ввод):

      ```bash
      # io::confirm_action
      io::confirm_action "$(_ "key")"

      # io::ask_value
      io::ask_value "$(_ "key")" "$default" "$pattern" "$hint"

      # printf с переводом
      printf "$(i18n::get "key")" "$arg1"
      ```

      * НЕ ИСПОЛЬЗУЙТЕ `_()` в логерах:

      ```bash
      # ОШИБКА - двойной перевод!
      log_info "$(_ "key")"             # log_info сам вызывает _()

      # ПРАВИЛЬНО
      log_info "key"                     # log_info сам переведёт
      ```

    - Файлы переводов:
      * lib/i18n/ru/common.sh - общие сообщения (русский)
      * lib/i18n/en/common.sh - общие сообщения (английский)
      * lib/i18n/ru/ssh.sh - SSH модуль (русский)
      * lib/i18n/en/ssh.sh - SSH модуль (английский)
      * lib/i18n/ru/ufw.sh - UFW модуль (русский)
      * lib/i18n/en/ufw.sh - UFW модуль (английский)
      * lib/i18n/ru/system.sh - системные сообщения (русский)
      * lib/i18n/en/system.sh - системные сообщения (английский)

    - Добавление новых переводов:
      1. Добавьте ключ в lib/i18n/ru/domain.sh
      2. Добавьте тот же ключ с переводом в lib/i18n/en/domain.sh
      3. Используйте ключ в коде через `log_info "key"` или `io::confirm_action "$(_ "key")"`

    - Переключение языка:
      * Русский (по умолчанию): удалить файл .lang или оставить пустым
      * Английский: `echo "en" > .lang`
      * Другие языки: создайте папку lib/i18n/{lang}/ и соответствующие файлы
```

### Структура переводов

Переводы организованы по модулям:

```
lib/i18n/
├── core.sh              # Основная функция _()
├── loader.sh            # Загрузка переводов по языку
├── ru/                   # Русские переводы
│   ├── common.sh        # Общие сообщения
│   ├── ssh.sh           # SSH модуль
│   ├── ufw.sh           # UFW модуль
│   └── system.sh         # Системные сообщения
└── en/                   # Английские переводы
    ├── common.sh
    ├── ssh.sh
    ├── ufw.sh
    └── system.sh
```

### Использование i18n в коде

**Замена жестких строк на ключи:**
Было:
```bash
log_info "Доступные действия:"
```

Стало:
```bash
log_info "common.info_available_modules"
```

**Форматирование сообщений:**
```bash
# Без аргументов
log_info "ssh.success_port_up" "$port" "$attempts" "$elapsed"

# С аргументами
log_success "ssh.success_port_up" "$port" "$attempts" "$elapsed"
```

**Конвенции именования ключей:**

- Формат: `module.submodule.action.message_type`
- Примеры:
  - `common.error_root_privileges` - общая ошибка прав root
  - `ssh.ui.get_action_choice.available_actions` - UI выбор действий SSH
  - `ssh.success_port_up` - успешное сообщение о поднятии SSH порта
```
