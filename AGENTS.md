# Манифест проектирования: Bash-инженерия 2026

1. Фундаментальная философия
 - Данный проект — это не «скрипт», это модульный фреймворк на базе Unix-утилит. Мы не пишем императивный код, мы проектируем потоки данных.
  - Bash как клей: Мы используем Bash для управления процессами и файловыми дескрипторами. Вся тяжелая работа (парсинг, трансформация) делегируется специализированным инструментам: gawk (GNU Awk), sed, grep, xargs, ss.
 - Изоляция побочных эффектов: Каждая значимая модификация системы должна быть атомарной.
 - Потоковая архитектура (Pipeline-first): Данные «текут» через пайпы. Минимизируй использование переменных для хранения контента. Используй дескрипторы файлов и NUL-разделители (\0) для передачи путей и списков.

2. Золотой стандарт потоков (IO)
 - NUL-разделитель (\0): Единственный надежный способ передачи данных в пайплайнах. Пути к файлам, списки портов и любые массивы данных передаются через \0.
 - Догма: «NUL живет в трубе, но умирает в переменной».
 - Чистота FD 1 (stdout): Только чистые данные для следующего звена.
 - Диагностика FD 2 (stderr): Все логи, интерфейсы, подтверждения и интерактив — строго в stderr. (Используй систему логирования проекта - log_info, log_error и прочие в logging.sh, для подтверждения действия используй - io::confirm_action в user_confirmation.sh, для выбора значения io::ask_value там же.)
 - Запрет на eval: Никогда не использовать eval для выполнения строк, полученных из парсинга. Используй массивы, xargs или прямой вызов.
 - Разделение потоков (FD 0, 1, 2): stdout (FD 1) — строго чистые данные для следующего звена. stderr (FD 2) — интерфейс, логирование (log_info), диагностика и интерактив.

3. Архитектура ролей (Namespacing)
 - Функции обязаны иметь префиксы для обозначения своей зоны ответственности:
   - orchestrator:: — высокоуровневая логика и переключение сценариев.
   - ssh::, ufw::, grub:: и т.д. — специфичные провайдеры (библиотеки) для сервисов.
   - io:: — взаимодействие с пользователем и логирование.
   - sys:: — низкоуровневые системные проверки (порты, файлы, процессы).
 - Никаких монолитов. Одна функция — одна атомарная задача.

  4. Контракт функции (Аннотации)
   - Перед каждой функцией обязательна аннотация:
```bash
# @type:        Source | Filter | Transformer | Orchestrator | Sink | UNDEFINED
# @description: Краткое описание физики действия
# @stdin:       Формат входящих данных (например, NUL-separated paths (path\0))
# @stdout:      Формат выходящих данных
# @exit_code:   0 - успех
#               2 - намеренная отмена пользователем (SIGINT-like)
#               >0 - ошибка (кроме 2)
```

   - Стандарт обработки статусов BSSS:
     * Модули обязаны возвращать 0 при успехе и 2 при намеренной отмене пользователем.
     * Диспетчер (Runner) обязан интерпретировать код 2 как информационный сигнал SIGINT-like, не прерывая цикл работы.
     * Любой другой код > 0 (кроме 2) интерпретируется как CRITICAL ошибка.

  4.1. Коды возврата BSSS
   - Система использует стандартизированные коды возврата для обозначения состояний:
     
     | Код | Описание | Категория | Обработка в Runner |
     |-----|----------|-----------|-------------------|
     | 0 | Успешное завершение | SUCCESS | Информационное сообщение |
     | 2 | Намеренная отмена пользователем | INFO | Информационное сообщение, продолжение цикла |
     | 3 | Завершение через механизм rollback (watchdog) | INFO | Информационное сообщение, продолжение цикла |
     | 4 | Требуется предварительная настройка | INFO | Информационное сообщение, продолжение цикла |
     | 130 | Прерывание по Ctrl+C | INFO | Эквивалент кода 2 |
     | 1, >4 | Критическая ошибка | CRITICAL | Ошибка с логированием пути к модулю |

   - Информационные коды (2, 3, 4, 130) не прерывают основной цикл модификации
   - Коды возврата документируются в контракте функции (@exit_code)
   - Используйте код 4 когда модуль требует предварительных условий для выполнения

  5. Инструментарий
  - Критическая зависимость: gawk (GNU Awk)
    * Проверка наличия: sys::gawk::check_dependency (вызывается в main.sh)
    * Обязательное использование: Все вызовы awk должны быть явно указаны как gawk
    * Причина: Проект использует NUL-разделители (\0), которые корректно поддерживает только GNU Awk
    * Синтаксис: Используется синтаксис gawk (например, ORS="\0", RS='\0', match() с массивами)
 - Использование read -r -d ''.
 - Использование mapfile -d ''.
 - Использование sort -z, xargs -0.
 - Использование современных стандартов GNU Coreutils (mapfile -d '', read -d '', sort -z, gawk ORS="\0").
 - Конвенция путей: Все пути из vars.conf задаются БЕЗ завершающего и начального слеша. Не используйте ${var%/} для переменных из vars.conf (за исключением динамически получаемых параметров функций).

6. Архитектурные принципы
 - Идемпотентность: Повторный запуск скрипта не ломает систему. Используй маркеры # Generated by BSSS.
 - Выживаемость (Watchdog): Критические изменения (SSH) защищаются фоновыми процессами-сторожами (nohup, sleep в фоне, trap по сигналам SIGUSR1).
 - Безопасность: ПОЛНЫЙ ЗАПРЕТ использования eval. Строгая валидация ввода через регулярные выражения.
 - Робастность: Пайплайны должны завершаться с кодом 0. Используй || true для выживаемости скрипт - например в rollback.sh - маскируем || ошибки закрытых каналов FIFO при логировании, что бы максимализировать устойчивость роллбека.

7. Карта функций и переиспользование кода
 - function_map.txt содержит полный перечень всех функций проекта с их типами, описанием и расположением.
 - Формат: ID | функция() | тип | описание | путь_к_файлу
 - Использование карты функций:
   * Перед написанием нового функционала всегда проверяйте function_map.txt на наличие существующих решений
   * Ищите функции по ключевым словам в описании или по префиксам имен (ssh::, ufw::, sys:: и т.д.)
   * Используйте функции из существующих модулей для построения пайплайнов обработки данных
 - Размещение хелперов:
   * Общие хелперы (используемые в нескольких несвязанных модулях) → modules/common-helpers.sh
   * Специфичные хелперы (используемые только в одном типе модулей) → соответствующий файл модуля
     * SSH-хелперы → modules/04-ssh-port-helpers.sh
     * UFW-хелперы → modules/04-ssh-port-helpers.sh
     * Другие доменные хелперы → modules/[domain]-helpers.sh
 - Принципы переиспользования:
   * Предпочитайте композицию функций через пайплайны созданию дублирующего кода
   * Соблюдайте контракты функций (stdin/stdout/exit_code) при построении пайплайнов
   * Используйте префиксы имен функций для быстрого поиска в карте функций

 8. Типы функций и их назначение
 - Source (Источник): Генерирует поток (например, get_paths через printf %s\0).
 - Filter/Transformer (Фильтр): Принимает stdin, отдает stdout (предпочтение gawk, sed, grep, xargs -0).
 - Validator/Orchestrator (Диспетчер): Принимает решения, управляет логикой запуска других функций.
 - Sink: Потребляет поток данных, не передает дальше (например, запись в файл, выполнение команды).

9. Примеры
 - Оркестрация
```bash
# @type:        Orchestrator
# @description: Обработчик сценария отсутствия конфигурации SSH
#               Установка нового порта SSH и добавление правила в UFW
# @params:      нет
# @stdin:       нет
# @stdout:      нет
# @exit_code:   0 — успешно
#               $? — код ошибки дочернего процесса
ssh::orchestrator::config_not_exists() {
    ssh::ui::get_new_port | ssh::rule::reset_and_pass | ufw::rule::reset_and_pass | ssh::port::install_new
    ssh::orchestrator::log_statuses
}
```
 - Фильтр
```bash
# @type:        Filter
# @description: Удаляет все правила UFW BSSS и передает порт дальше
# @params:      нет
# @stdin:       port\0 (опционально)
# @stdout:      port\0 (опционально)
# @exit_code:   0 - успешно
ufw::rule::reset_and_pass() {
    local port=""

    # || true нужен что бы гасить код 1 при false кода [[ ! -t 0 ]]
    [[ ! -t 0 ]] && IFS= read -r -d '' port || true
    
    ufw::rule::delete_all_bsss

    # || true нужен что бы гасить код 1 при false кода [[ -n "$port" ]]
    [[ -n "$port" ]] && printf '%s\0' "$port" || true
}
```
 - Источник
```bash
# @type:        Source
# @description: Генерирует случайный свободный порт в диапазоне 10000-65535
# @params:      нет
# @stdin:       нет
# @stdout:      port
# @exit_code:   0 - порт успешно сгенерирован
#               $? - ошибка
ssh::port::generate_free_random_port() {
    while IFS= read -r port || break; do
        if ! ssh::port::is_port_free "$port"; then
            printf '%s\n' "$port"
            return
        fi
    done < <(shuf -i 10000-65535)
}
```
  - Шапка исполняемых файлов
    - Добавляется ТОЛЬКО в файлы, которые могут выполняться напрямую
    - Пример с полями:
```
#!/usr/bin/env bash
# Изменяет SSH порт
# MODULE_ORDER: 60
# MODULE_TYPE: modify
# MODULE_NAME: module.ssh.name # Имя модуля использутся в формировании меню и по этому указывается название переменной перевода
```
    - Пример без полей:
```
#!/usr/bin/env bash
# Проверяет синхронизацию файлов переводов
```
  - Шапка может отсутствовать в файлах хелперах и прочих файлах подключаемых через source
  - Дополнительные примеры
    - [modules/04-ssh-port-helpers.sh](modules/04-ssh-port-helpers.sh)
    - [modules/04-ssh-port-modify.sh](modules/04-ssh-port-modify.sh)
    - [main.sh](main.sh)

 10. Инструменты разработки и команды
 - Генерация карты функций: `./utils/generate_function_map.sh` — обновляет function_map.txt с актуальными контрактами всех функций
 - Линтинг: Используй shellcheck для проверки кода (при наличии)
 - Форматирование: При необходимости используй shfmt для согласования отступов
  - Запуск основного скрипта: `./main.sh` для локального тестирования
 - Запуск модуля напрямую: `bash modules/04-ssh-port-helpers.sh` для тестирования отдельных компонентов
 - Активация строгого режима: `set -Eeuo pipefail` в начале каждого скрипта (E=exit on error, e=exit on undefined var, u=pipefail)

  11. Конвенции стиля кода
   - Shebang: 
     * Добавляется ТОЛЬКО в файлы, которые могут выполняться напрямую (main.sh, модули, тесты)
     * НЕ добавляется в файлы, которые подгружаются через source (хелперы, библиотеки: lib/i18n/loader.sh, lib/logging.sh и т.д.)
     * Если файл подразумевает прямой запуск, в конце файла должна быть проверка:
       ```bash
       if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
           main "$@"
       fi
       ```
   - Отступы: Используй пробелы (не табы), стандартный отступ — 4 пробела
  - Переменные: readonly для констант (определяются в lib/vars.conf), local для временных переменных внутри функций
  - Путь к корню проекта: `${PROJECT_ROOT}` — должен быть определен как `readonly PROJECT_ROOT="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")" )" && pwd)"`
  - Имя текущего модуля: `${CURRENT_MODULE_NAME}` — используется в логировании
  - Комментарии shellcheck: Используй `# shellcheck disable=SCCODE` только при обоснованной необходимости
  - Использование gawk: Все вызовы awk должны быть явно указаны как gawk. Никогда не используйте просто awk
  - Идемпотентность: Каждая операция должна быть идемпотентной. Используй маркеры "# Generated by BSSS" для идентификации сгенерированных файлов
  - Валидация входных данных: Строгая проверка через регулярные выражения (пример: `"^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"` для портов)

  12. Философия разработки
  - Критический аудит: Если видишь возврат к императивному стилю (массивы там, где нужен поток), мягко возвращай к «поточной» архитектуре.
  - Инструментарий: Используй современные стандарты GNU Coreutils (mapfile -d '', read -d '', sort -z, gawk ORS="\0").

  13. Стандарт нейминга функций
   - Фундаментальные принципы:
     * Иерархия: domain::subdomain::action (максимум 3 уровня)
     * Субдомены обязательны для всех функций кроме самых простых
     * Читаемость превыше краткости

   - Правила для action:
     * Дублирование ДОПУСТИМО, если:
       - Без него теряется смысл: ssh::port::generate_free_random_port (не generate_free_random)
       - Повышает однозначность: ssh::port::is_port_free (лучше чем is_busy)
       - Существительное — важная часть действия
     * Дублирование НЕ обязательно, если:
       - Субдомен уже однозначно указывает объект: ufw::ping::is_configured (не is_ping_configured)
       - Действие очевидно из контекста

   - Примеры нейминга:
     * Оркестраторы: ssh::ssh::orchestrator::log_statuses, ufw::orchestrator::run_module

   14. I18n (Internationalization)
     - Подробная документация: [lib/i18n/README.md](lib/i18n/README.md)

     - Архитектура:
       * Использует ассоциативные массивы Bash 4+ для переводов
       * Файловая структура: lib/i18n/{ru|en}/domain.sh
       * Переключение языка через файл .lang в корне проекта

     - Стандарт использования переводов:
       * **Все функции** (io::confirm_action, io::ask_value, log_info, log_error): перевод делается ДО вызова, функция принимает уже переведенную строку
       * Переводы в файлах переводов могут поддерживать аргументы через printf форматирование (например, `I18N_MESSAGES["key"]="Сообщение %s"`)
        * Достаем перевод "$(_ \"key\" \"arg1\")" или если нет примающих параметров, то "$(_ \"key\")"

     - Правильные примеры вызовов:

        ```bash
        # io::confirm_action - перевод делается ДО вызова
        io::confirm_action "$(_ \"key\")"
        
        # Пример функции ask_value
        io::ask_value() {
         local question=$1 default=$2 pattern=$3 hint=$4 cancel_keyword=${5:-}
         ...
         }

        # Вызов ask_value
        # io::ask_value - перевод делается ДО вызова
        io::ask_value "$(_ \"key\")" "$default" "$pattern" "$hint"
        или
        io::ask_value "$(_ \"key\")" "$default" "$pattern" "$(_ \"key\" \"arg1\")" "n"

        # Логеры - перевод делается ДО вызова
        log_info "$(_ \"key\" \"arg1\" \"arg2\")"
        log_error "$(_ \"key\")"
        ```

        ```bash
        # Пример перевода с аргументами в файле переводов:
        # lib/i18n/ru/common.sh:
        # I18N_MESSAGES["common.helpers.ufw.rule.delete_error"]="Ошибка удаления правила: %s"

        # Использование в коде:
        log_error "$(_ \"common.helpers.ufw.rule.delete_error\" \"$rule_args\")"
        ```

     - Конвенции именования ключей:
       * Формат: module.submodule.action.message_type
       * Примеры:
         - `common.error_root_privileges` - общие ошибки
         - `ufw.status.enabled` - статусы UFW

     - Заглушка `no_translate`:
       * Используется для вывода текста без перевода (пути к файлам, динамические строки)
       * Определена в common.sh: `I18N_MESSAGES["no_translate"]="%s"`
       * Примеры использования:

        ```bash
        # Путь к файлу
        log_info_simple_tab "$(_ \"no_translate\" \"/etc/ssh/sshd_config:Port 22\")"
        ```

      - Файлы переводов:
        * lib/i18n/ru/common.sh - общие сообщения (русский)
        * lib/i18n/en/common.sh - общие сообщения (английский)
        * lib/i18n/ru/ssh.sh - SSH модуль (русский)
        * lib/i18n/en/ssh.sh - SSH модуль (английский)
        * lib/i18n/ru/ufw.sh - UFW модуль (русский)
        * lib/i18n/en/ufw.sh - UFW модуль (английский)
        * lib/i18n/ru/system.sh - системные сообщения (русский)
        * lib/i18n/en/system.sh - системные сообщения (английский)

        - Добавление новых переводов:
          * **Правило для агентов-программистов**: При необходимости добавить новый лог (log_info, log_error и т.д.) нужно в первую очередь создавать переменную перевода (локализации) в файле русского языка (lib/i18n/ru/domain.sh)
          * Другие языковые локализации (en и др.) создавать не обязательно — этим будет заниматься другой агент-переводчик
          * Задача агента, который программирует — создать одну локализацию (русскую)
          * Процесс:
            1. Добавьте ключ в lib/i18n/ru/domain.sh (обязательно)
            2. Используйте ключ в коде через `log_info "$(_ \"key\")"` или `io::confirm_action "$(_ \"key\")"`
            3. Остальные языки добавляются другим агентом (translation agent)

### Структура переводов

Переводы организованы по модулям:

```
lib/i18n/
 ├── test_translations.sh       # Проверка целостности переводов между языками
 ├── test_unused_translations.sh # Проверка неиспользуемых переводов
 ├── test_unknown_translations.sh # Проверка неизвестных переводов
 ├── loader.sh                   # Загрузка переводов по языку Основная функция _()
 ├── ru/                         # Русские переводы
 │   ├── common.sh               # Общие сообщения
 │   ├── ssh.sh                  # SSH модуль
 │   ├── ufw.sh                  # UFW модуль
 │   └── system.sh               # Системные сообщения
 └── en/                         # Английские переводы
     ├── common.sh
     ├── ssh.sh
     ├── ufw.sh
     └── system.sh
```

### Примеры хорошего кода
  - Предпочтительна потоковая архитектура
```bash
# Пример 1
# ПЛОХО: Избыточная логика, использование переменных там, где нужен поток
i18n::detect_language() {
    local lang_file="${PROJECT_ROOT}/.lang"
    if [[ -f "$lang_file" ]]; then
        local detected_lang
        detected_lang=$(cat "$lang_file" 2>/dev/null | tr -d '[:space:]')
        echo "$detected_lang"
    else
        echo "$DEFAULT_LANG"
    fi
}

# ХОРОШО: Потоковый стиль, прозрачный вывод (Idempotent output)
i18n::detect_language() {
    [[ -f "$LANG_FILE" ]] && cat "$LANG_FILE" 2>/dev/null | tr -d '[:space:]' || printf '%s' "$DEFAULT_LANG"
}

# Пример 2
# Плохой код
i18n::load_translations() {
    local lang_code="$1"
    local i18n_dir="${PROJECT_ROOT}/lib/i18n/${lang_code}"
    
    if [[ ! -d "$i18n_dir" ]]; then
        echo "i18n directory not found: $i18n_dir" >&2
        return 1
    fi
    
    # Плохо - глобальный массив должен объявляется в общем конфигурационном файле, а не в коде проекта
    declare -gA I18N_MESSAGES=()
    
    local translation_files
    mapfile -t translation_files < <(find "$i18n_dir" -maxdepth 1 -name "*.sh" -type f | sort)
    
    for file in "${translation_files[@]}"; do
        if [[ -r "$file" ]]; then
            . "$file"
        fi
    done
}

# Хороший код (Streaming Style)
i18n::load_translations() {
    local lang_code i18n_dir path

    read -r lang_code
    i18n_dir="${I18N_DIR}/${lang_code}"
    
    [[ ! -d "$i18n_dir" ]] && return 1
    
    while IFS= read -r -d '' path; do
        [[ -f "$path" ]] && source "$path"
    done < <(find "$i18n_dir" -type f -maxdepth 1 -name "*.sh" -print0)
}

# Пример 3
# Плохой код
i18n::load() {
    local lang
    lang=$(i18n::detect_language)
    
    if ! i18n::load_translations "$lang"; then
        return 1
    fi
    
    return 0
}

# Хороший код
i18n::load() {
    i18n::load_translations <<< "$(i18n::detect_language)"
}
```