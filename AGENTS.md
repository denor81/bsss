# Манифест проектирования: Bash-инженерия 2026

1. Фундаментальная философия
 - Данный проект — это не «скрипт», это модульный фреймворк на базе Unix-утилит. Мы не пишем императивный код, мы проектируем потоки данных.
 - Bash как клей: Мы используем Bash для управления процессами и файловыми дескрипторами. Вся тяжелая работа (парсинг, трансформация) делегируется специализированным инструментам: awk, sed, grep, xargs, ss.
 - Изоляция побочных эффектов: Каждая значимая модификация системы должна быть атомарной.
 - Потоковая архитектура (Pipeline-first): Данные «текут» через пайпы. Минимизируй использование переменных для хранения контента. Используй дескрипторы файлов и NUL-разделители (\0) для передачи путей и списков.

2. Золотой стандарт потоков (IO)
 - NUL-разделитель (\0): Единственный надежный способ передачи данных в пайплайнах. Пути к файлам, списки портов и любые массивы данных передаются через \0.
 - Догма: «NUL живет в трубе, но умирает в переменной».
 - Чистота FD 1 (stdout): Только чистые данные для следующего звена.
 - Диагностика FD 2 (stderr): Все логи, интерфейсы, подтверждения и интерактив — строго в stderr. (Используй систему логирования проекта - log_info, log_error и прочие в logging.sh, для подтверждения действия используй - io::confirm_action в user_confirmation.sh, для выбора значения io::ask_value там же.)
 - Запрет на eval: Никогда не использовать eval для выполнения строк, полученных из парсинга. Используй массивы, xargs или прямой вызов.
 - Разделение потоков (FD 0, 1, 2): stdout (FD 1) — строго чистые данные для следующего звена. stderr (FD 2) — интерфейс, логирование (log_info), диагностика и интерактив.

3. Архитектура ролей (Namespacing)
 - Функции обязаны иметь префиксы для обозначения своей зоны ответственности:
   - orchestrator:: — высокоуровневая логика и переключение сценариев.
   - ssh::, ufw::, grub:: и т.д. — специфичные провайдеры (библиотеки) для сервисов.
   - io:: — взаимодействие с пользователем и логирование.
   - sys:: — низкоуровневые системные проверки (порты, файлы, процессы).
 - Никаких монолитов. Одна функция — одна атомарная задача.

4. Контракт функции (Аннотации)
  - Перед каждой функцией обязательна аннотация:
```bash
# @type:        Source | Filter | Transformer | Orchestrator | Sink | UNDEFINED
# @description: Краткое описание физики действия
# @stdin:       Формат входящих данных (например, NUL-separated paths (path\0))
# @stdout:      Формат выходящих данных
# @exit_code:   0 - успех
#               2 - намеренная отмена пользователем (SIGINT-like)
#               >0 - ошибка (кроме 2)
```

  - Стандарт обработки статусов BSSS:
    * Модули обязаны возвращать 0 при успехе и 2 при намеренной отмене пользователем.
    * Диспетчер (Runner) обязан интерпретировать код 2 как информационный сигнал SIGINT-like, не прерывая цикл работы.
    * Любой другой код > 0 (кроме 2) интерпретируется как CRITICAL ошибка.

5. Инструментарий
 - Использование read -r -d ''.
 - Использование mapfile -d ''.
 - Использование sort -z, xargs -0.
 - Использование современных стандартов GNU Coreutils (mapfile -d '', read -d '', sort -z, awk ORS="\0").

6. Архитектурные принципы 2026 года
 - Идемпотентность: Повторный запуск скрипта не ломает систему. Используй маркеры # Generated by BSSS.
 - Выживаемость (Watchdog): Критические изменения (SSH) защищаются фоновыми процессами-сторожами (nohup, sleep в фоне, trap по сигналам SIGUSR1).
 - Безопасность: ПОЛНЫЙ ЗАПРЕТ использования eval. Строгая валидация ввода через регулярные выражения.
 - Робастность: Пайплайны должны завершаться с кодом 0. Используй || true для tail -f или специфические awk-фильтры для обработки сигналов SIGPIPE (141) и завершающих маркеров (EOF).

7. Карта функций и переиспользование кода
 - function_map.txt содержит полный перечень всех функций проекта с их типами, описанием и расположением.
 - Формат: ID | функция() | тип | описание | путь_к_файлу
 - Использование карты функций:
   * проверяй function_map.txt на наличие существующих решений только при написании нового функционала
   * Ищите функции по ключевым словам в описании или по префиксам имен (ssh::, ufw::, sys:: и т.д.)
   * Используйте функции из существующих модулей для построения пайплайнов обработки данных
 - Размещение хелперов:
   * Общие хелперы (используемые в нескольких несвязанных модулях) → modules/common-helpers.sh
   * Специфичные хелперы (используемые только в одном типе модулей) → соответствующий файл модуля
     * SSH-хелперы → modules/04-ssh-port-helpers.sh
     * UFW-хелперы → modules/04-ssh-port-helpers.sh
     * Другие доменные хелперы → modules/[domain]-helpers.sh
 - Принципы переиспользования:
   * Предпочитайте композицию функций через пайплайны созданию дублирующего кода
   * Соблюдайте контракты функций (stdin/stdout/exit_code) при построении пайплайнов
   * Используйте префиксы имен функций для быстрого поиска в карте функций

8. Типы функций и их назначение
 - Source (Источник): Генерирует поток (например, get_paths через printf %s\0).
 - Filter/Transformer (Фильтр): Принимает stdin, отдает stdout (предпочтение awk, sed, grep, xargs -0).
 - Validator/Orchestrator (Диспетчер): Принимает решения, управляет логикой запуска других функций.
 - Sink: Потребляет поток данных, не передает дальше (например, запись в файл, выполнение команды).

9. Примеры
 - Оркестрация
```bash
# @type:        Orchestrator
# @description: Обработчик сценария отсутствия конфигурации SSH
#               Установка нового порта SSH и добавление правила в UFW
# @params:      нет
# @stdin:       нет
# @stdout:      нет
# @exit_code:   0 — упешно
#               $? — код ошибки дочернего процесса
orchestrator::bsss_config_not_exists() {
    ssh::ask_new_port | ssh::reset_and_pass | ufw::reset_and_pass | ssh::install_new_port
    orchestrator::actions_after_port_change
}
```
 - Фильтр
```bash
# @type:        Filter
# @description: Удаляет все правила UFW BSSS и передает порт дальше
# @params:      нет
# @stdin:       port\0 (опционально)
# @stdout:      port\0 (опционально)
# @exit_code:   0 - успешно
ufw::reset_and_pass() {
    local port=""

    # || true нужен что бы гасить код 1 при false кода [[ ! -t 0 ]]
    [[ ! -t 0 ]] && IFS= read -r -d '' port || true
    
    ufw::delete_all_bsss_rules

    # || true нужен что бы гасить код 1 при false кода [[ -n "$port" ]]
    [[ -n "$port" ]] && printf '%s\0' "$port" || true
}
```
 - Источник
```bash
# @type:        Source
# @description: Генерирует случайный свободный порт в диапазоне 10000-65535
# @params:      нет
# @stdin:       нет
# @stdout:      port
# @exit_code:   0 - порт успешно сгенерирован
#               $? - ошибка
ssh::generate_free_random_port() {
    while IFS= read -r port || break; do
        if ! ssh::is_port_busy "$port"; then
            printf '%s\n' "$port"
            return
        fi
    done < <(shuf -i 10000-65535)
}
```
 - Дополнительные примеры
   - [modules/04-ssh-port-helpers.sh](modules/04-ssh-port-helpers.sh)
   - [modules/04-ssh-port-modify.sh](modules/04-ssh-port-modify.sh)
   - [local-runner.sh](local-runner.sh)

10. Философия обучения и разработки
 - Лаконичность и «физика»: Объясняй решения через работу ядра, системные вызовы (fork, exec), буферы труб и дескрипторы файлов.
 - Критический аудит: Если видишь возврат к императивному стилю (массивы там, где нужен поток), мягко возвращай к «поточной» архитектуре.
 - Инструментарий 2026: Используй современные стандарты GNU Coreutils (mapfile -d '', read -d '', sort -z, awk ORS="\0").
 - Текущее состояние проекта: Мы разработали модульный фреймворк для настройки системных параметров (на примере SSH). Реализована динамическая система обнаружения модулей по типам (check, modify, helper) с использованием метаданных в заголовках файлов. Система построена на базе «Умных источников» и «Диспетчеров», которые управляют логикой установки и сброса конфигураций.
