# Манифест проектирования: Bash-инженерия 2026

1. Фундаментальная философия
 - Данный проект — это не «скрипт», это модульный фреймворк на базе Unix-утилит. Мы не пишем императивный код, мы проектируем потоки данных.
 - Bash как клей: Мы используем Bash для управления процессами и файловыми дескрипторами. Вся тяжелая работа (парсинг, трансформация) делегируется специализированным инструментам: awk, sed, grep, xargs, ss.
 - Изоляция побочных эффектов: Каждая значимая модификация системы должна быть атомарной.
 - Потоковая архитектура (Pipeline-first): Данные «текут» через пайпы. Минимизируй использование переменных для хранения контента. Используй дескрипторы файлов и NUL-разделители (\0) для передачи путей и списков.

2. Золотой стандарт потоков (IO)
 - NUL-разделитель (\0): Единственный надежный способ передачи данных в пайплайнах. Пути к файлам, списки портов и любые массивы данных передаются через \0.
 - Догма: «NUL живет в трубе, но умирает в переменной».
 - Чистота FD 1 (stdout): Только чистые данные для следующего звена.
 - Диагностика FD 2 (stderr): Все логи, интерфейсы, подтверждения и интерактив — строго в stderr. (Используй систему логирования проекта - log_info, log_error и прочие в logging.sh, для подтверждения действия используй - io::confirm_action в user_confirmation.sh, для выбора значения io::ask_value там же.)
 - Запрет на eval: Никогда не использовать eval для выполнения строк, полученных из парсинга. Используй массивы, xargs или прямой вызов.
 - Разделение потоков (FD 0, 1, 2): stdout (FD 1) — строго чистые данные для следующего звена. stderr (FD 2) — интерфейс, логирование (log_info), диагностика и интерактив.

3. Архитектура ролей (Namespacing)
 - Функции обязаны иметь префиксы для обозначения своей зоны ответственности:
   - orchestrator:: — высокоуровневая логика и переключение сценариев.
   - ssh::, ufw::, grub:: и т.д. — специфичные провайдеры (библиотеки) для сервисов.
   - io:: — взаимодействие с пользователем и логирование.
   - sys:: — низкоуровневые системные проверки (порты, файлы, процессы).
 - Никаких монолитов. Одна функция — одна атомарная задача.

  4. Контракт функции (Аннотации)
   - Перед каждой функцией обязательна аннотация:
```bash
# @type:        Source | Filter | Transformer | Orchestrator | Sink | UNDEFINED
# @description: Краткое описание физики действия
# @stdin:       Формат входящих данных (например, NUL-separated paths (path\0))
# @stdout:      Формат выходящих данных
# @exit_code:   0 - успех
#               2 - намеренная отмена пользователем (SIGINT-like)
#               >0 - ошибка (кроме 2)
```

   - Стандарт обработки статусов BSSS:
     * Модули обязаны возвращать 0 при успехе и 2 при намеренной отмене пользователем.
     * Диспетчер (Runner) обязан интерпретировать код 2 как информационный сигнал SIGINT-like, не прерывая цикл работы.
     * Любой другой код > 0 (кроме 2) интерпретируется как CRITICAL ошибка.

  4.1. Коды возврата BSSS
   - Система использует стандартизированные коды возврата для обозначения состояний:
     
     | Код | Описание | Категория | Обработка в Runner |
     |-----|----------|-----------|-------------------|
     | 0 | Успешное завершение | SUCCESS | Информационное сообщение |
     | 2 | Намеренная отмена пользователем | INFO | Информационное сообщение, продолжение цикла |
     | 3 | Завершение через механизм rollback (watchdog) | INFO | Информационное сообщение, продолжение цикла |
     | 4 | Требуется предварительная настройка | INFO | Информационное сообщение, продолжение цикла |
     | 130 | Прерывание по Ctrl+C | INFO | Эквивалент кода 2 |
     | 1, >4 | Критическая ошибка | CRITICAL | Ошибка с логированием пути к модулю |

   - Информационные коды (2, 3, 4, 130) не прерывают основной цикл модификации
   - Коды возврата документируются в контракте функции (@exit_code)
   - Используйте код 4 когда модуль требует предварительных условий для выполнения

 5. Инструментарий
 - Использование read -r -d ''.
 - Использование mapfile -d ''.
 - Использование sort -z, xargs -0.
 - Использование современных стандартов GNU Coreutils (mapfile -d '', read -d '', sort -z, awk ORS="\0").
 - Конвенция путей: Все пути из vars.conf задаются БЕЗ завершающего и начального слеша. Не используйте ${var%/} для переменных из vars.conf (за исключением динамически получаемых параметров функций).

6. Архитектурные принципы 2026 года
 - Идемпотентность: Повторный запуск скрипта не ломает систему. Используй маркеры # Generated by BSSS.
 - Выживаемость (Watchdog): Критические изменения (SSH) защищаются фоновыми процессами-сторожами (nohup, sleep в фоне, trap по сигналам SIGUSR1).
 - Безопасность: ПОЛНЫЙ ЗАПРЕТ использования eval. Строгая валидация ввода через регулярные выражения.
 - Робастность: Пайплайны должны завершаться с кодом 0. Используй || true для tail -f или специфические awk-фильтры для обработки сигналов SIGPIPE (141) и завершающих маркеров (EOF).

7. Карта функций и переиспользование кода
 - function_map.txt содержит полный перечень всех функций проекта с их типами, описанием и расположением.
 - Формат: ID | функция() | тип | описание | путь_к_файлу
 - Использование карты функций:
   * Перед написанием нового функционала всегда проверяйте function_map.txt на наличие существующих решений
   * Ищите функции по ключевым словам в описании или по префиксам имен (ssh::, ufw::, sys:: и т.д.)
   * Используйте функции из существующих модулей для построения пайплайнов обработки данных
 - Размещение хелперов:
   * Общие хелперы (используемые в нескольких несвязанных модулях) → modules/common-helpers.sh
   * Специфичные хелперы (используемые только в одном типе модулей) → соответствующий файл модуля
     * SSH-хелперы → modules/04-ssh-port-helpers.sh
     * UFW-хелперы → modules/04-ssh-port-helpers.sh
     * Другие доменные хелперы → modules/[domain]-helpers.sh
 - Принципы переиспользования:
   * Предпочитайте композицию функций через пайплайны созданию дублирующего кода
   * Соблюдайте контракты функций (stdin/stdout/exit_code) при построении пайплайнов
   * Используйте префиксы имен функций для быстрого поиска в карте функций

8. Типы функций и их назначение
 - Source (Источник): Генерирует поток (например, get_paths через printf %s\0).
 - Filter/Transformer (Фильтр): Принимает stdin, отдает stdout (предпочтение awk, sed, grep, xargs -0).
 - Validator/Orchestrator (Диспетчер): Принимает решения, управляет логикой запуска других функций.
 - Sink: Потребляет поток данных, не передает дальше (например, запись в файл, выполнение команды).

9. Примеры
 - Оркестрация
```bash
# @type:        Orchestrator
# @description: Обработчик сценария отсутствия конфигурации SSH
#               Установка нового порта SSH и добавление правила в UFW
# @params:      нет
# @stdin:       нет
# @stdout:      нет
# @exit_code:   0 — упешно
#               $? — код ошибки дочернего процесса
ssh::orchestrator::config_not_exists() {
    ssh::ui::get_new_port | ssh::rule::reset_and_pass | ufw::rule::reset_and_pass | ssh::port::install_new
    ssh::orchestrator::actions_after_port_change
}
```
 - Фильтр
```bash
# @type:        Filter
# @description: Удаляет все правила UFW BSSS и передает порт дальше
# @params:      нет
# @stdin:       port\0 (опционально)
# @stdout:      port\0 (опционально)
# @exit_code:   0 - успешно
ufw::rule::reset_and_pass() {
    local port=""

    # || true нужен что бы гасить код 1 при false кода [[ ! -t 0 ]]
    [[ ! -t 0 ]] && IFS= read -r -d '' port || true
    
    ufw::rule::delete_all_bsss

    # || true нужен что бы гасить код 1 при false кода [[ -n "$port" ]]
    [[ -n "$port" ]] && printf '%s\0' "$port" || true
}
```
 - Источник
```bash
# @type:        Source
# @description: Генерирует случайный свободный порт в диапазоне 10000-65535
# @params:      нет
# @stdin:       нет
# @stdout:      port
# @exit_code:   0 - порт успешно сгенерирован
#               $? - ошибка
ssh::port::generate_free_random_port() {
    while IFS= read -r port || break; do
        if ! ssh::port::is_port_free "$port"; then
            printf '%s\n' "$port"
            return
        fi
    done < <(shuf -i 10000-65535)
}
```
 - Дополнительные примеры
   - [modules/04-ssh-port-helpers.sh](modules/04-ssh-port-helpers.sh)
   - [modules/04-ssh-port-modify.sh](modules/04-ssh-port-modify.sh)
   - [local-runner.sh](local-runner.sh)

 10. Инструменты разработки и команды
 - Генерация карты функций: `./utils/generate_function_map.sh` — обновляет function_map.txt с актуальными контрактами всех функций
 - Линтинг: Используй shellcheck для проверки кода (при наличии)
 - Форматирование: При необходимости используй shfmt для согласования отступов
 - Запуск основного скрипта: `./bsss-main.sh` или `./local-runner.sh` для локального тестирования
 - Запуск модуля напрямую: `bash modules/04-ssh-port-helpers.sh` для тестирования отдельных компонентов
 - Активация строгого режима: `set -Eeuo pipefail` в начале каждого скрипта (E=exit on error, e=exit on undefined var, u=pipefail)

 11. Конвенции стиля кода
 - Shebang: Обязательное `#!/usr/bin/env bash` в начале всех bash-файлов
 - Отступы: Используй пробелы (не табы), стандартный отступ — 4 пробела
 - Переменные: readonly для констант (определяются в lib/vars.conf), local для временных переменных внутри функций
 - Путь к корню проекта: `${PROJECT_ROOT}` — должен быть определен как `readonly PROJECT_ROOT="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")" )" && pwd)"`
 - Имя текущего модуля: `${CURRENT_MODULE_NAME}` — используется в логировании
 - Комментарии shellcheck: Используй `# shellcheck disable=SCCODE` только при обоснованной необходимости
 - Идемпотентность: Каждая операция должна быть идемпотентной. Используй маркеры "# Generated by BSSS" для идентификации сгенерированных файлов
 - Валидация входных данных: Строгая проверка через регулярные выражения (пример: `"^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"` для портов)

 12. Философия обучения и разработки
 - Лаконичность и «физика»: Объясняй решения через работу ядра, системные вызовы (fork, exec), буферы труб и дескрипторы файлов.
 - Критический аудит: Если видишь возврат к императивному стилю (массивы там, где нужен поток), мягко возвращай к «поточной» архитектуре.
 - Инструментарий 2026: Используй современные стандарты GNU Coreutils (mapfile -d '', read -d '', sort -z, awk ORS="\0").
 - Текущее состояние проекта: Мы разработали модульный фреймворк для настройки системных параметров (на примере SSH). Реализована динамическая система обнаружения модулей по типам (check, modify, helper) с использованием метаданных в заголовках файлов. Система построена на базе «Умных источников» и «Диспетчеров», которые управляют логикой установки и сброса конфигураций.

 13. Стандарт нейминга функций
  - Фундаментальные принципы:
    * Иерархия: domain::subdomain::action (максимум 3 уровня)
    * Субдомены обязательны для всех функций кроме самых простых
    * Читаемость превыше краткости

  - Правила для action:
    * Дублирование ДОПУСТИМО, если:
      - Без него теряется смысл: ssh::port::generate_free_random_port (не generate_free_random)
      - Повышает однозначность: ssh::port::is_port_free (лучше чем is_busy)
      - Существительное — важная часть действия
    * Дублирование НЕ обязательно, если:
      - Субдомен уже однозначно указывает объект: ufw::ping::is_configured (не is_ping_configured)
      - Действие очевидно из контекста

  - Примеры нейминга:
    * Оркестраторы: ssh::ssh::orchestrator::actions_after_port_change, ufw::orchestrator::run_module
    * UI меню: ufw::menu::display, ufw::menu::get_user_choice
    * UI интерактивные: ssh::ui::get_new_port, ufw::toggle::status
    * Проверки: ssh::port::is_port_free, ssh::socket::is_configured
    * Генерация: ssh::port::generate_free_random_port, ssh::config::create_bsss_file
    * Удаление/сброс: ufw::rule::delete_all_bsss, ssh::rule::reset_and_pass
    * Системные: sys::file::validate_sshd_config, sys::service::restart
    * Запуск модулей: runner::module::run_check, runner::module::select_modify
    * Rollback: rollback::orchestrator::immediate, rollback::orchestrator::ssh

  - Домены и субдомены:
    * ufw: menu, ui, ping, rule
    * ssh: port, config, socket, ui
    * sys: file, service, process, update
    * io: confirm, input
    * log: border, message
    * orchestrator: только внутри домена (domain::orchestrator::action)
    * runner: module
    * rollback: orchestrator
