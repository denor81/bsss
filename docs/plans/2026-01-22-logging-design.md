# Logging System Design

## Overview

Система логирования для проекта BSSS, обеспечивающая запись всех потоков вывода (stdout и stderr) в файл с таймштампом для каждой сессии запуска.

## Architecture

Система логирования строится на базе перенаправления файловых дескрипторов в начале сессии `local-runner.sh`. Это соответствует pipeline-first философии проекта: данные "текут" через открытые дескрипторы, а явное перенаправление происходит один раз в точке входа.

Ключевая особенность: использование `exec > >(tee -a "$LOG_FILE") 2>&1`. Команда `exec` переопределяет FD 1 (stdout) для текущего процесса bash и всех его дочерних процессов. Фоновый процесс `tee` получает stdin от exec и дублирует его в два места: терминал (оригинальный FD 1, который tee наследует) и лог-файл. Перенаправление FD 2 на FD 1 (2>&1) объединяет stdout и stderr в один поток, который попадает в tee.

Важно: когда local-runner.sh выполняет `exec bash bsss-main.sh`, новый bash-процесс наследует уже переопределенные FD 1 и FD 2 от родительского процесса. Это гарантирует, что всё, что выводит bsss-main.sh и модули, автоматически попадает в лог-файл.

## Components and Placement

Система состоит из двух частей: инициализация в `local-runner.sh` и директория `./logs/` для хранения файлов.

### Initialization in local-runner.sh

Инициализация размещается в начале `local-runner.sh` сразу после определения констант (после строки 12). Три операции:

1. Создание директории logs (если не существует)
2. Генерация пути к файлу лога с таймштампом
3. Exec-перенаправление потоков

Использование `readonly` для LOG_FILE гарантирует неизменяемость пути.

```bash
# После source "${PROJECT_ROOT}/lib/uninstall_functions.sh"
mkdir -p "${PROJECT_ROOT}/logs"
readonly LOG_FILE="${PROJECT_ROOT}/logs/$(date +%Y-%m-%d_%H-%M-%S).log"
exec > >(tee -a "$LOG_FILE") 2>&1
```

### Log Directory

Директория `./logs/` создается в корне проекта при каждом запуске. Имя файла: `YYYY-MM-DD_HH-MM-SS.log` (формат `date +%Y-%m-%d_%H-%M-%S`). Гарантирует уникальность для каждого запуска и естественную сортировку по дате.

### Existing Code Compatibility

Никаких изменений в `lib/logging.sh` не требуется. Все существующие функции (log_info, log_error и т.д.) продолжают выводить в FD 2, который теперь перенаправлен через tee. Это сохраняет идеоматичность и backward compatibility.

Никаких дополнительных модулей или конфигурационных файлов не нужно. Система полностью самодостаточна и минимальна.

## Error Handling and Edge Cases

Фоновый процесс tee, запускаемый через `> >(...)`, автоматически получает SIGHUP от родительского shell при его завершении. Это гарантирует, что tee закроет файл лога корректно без утечек FD.

Создание директории logs через `mkdir -p` молча игнорирует, если директория уже существует. Если создание невозможно (нет прав на запись в корень проекта), `mkdir -p` вернет код 1, и ошибка будет выведена в stderr. Поскольку `set -Eeuo pipefail` включен в local-runner.sh, скрипт завершится с ошибкой еще до перенаправления потоков. Лог-файл не будет создан, но это корректное поведение: если нет прав на запись, логирование невозможно.

Запись в файл через tee с флагом `-a` (append) гарантирует, что файл создается при первой записи, а не при открытии FD. Если диск заполнен или нет прав на запись в файл, tee вернет код ошибки. Ошибка будет видна в терминале (stdout) и в stderr, но не прервет выполнение скрипта из-за того, что tee работает в фоне. Это компромисс: потеря логов не должна останавливать выполнение, пользователь увидит ошибку в терминале.

Перенаправление с помощью exec нельзя отменить в рамках сессии. Это намеренное ограничение, соответствующее философии "один раз настроил и забыл".

## ANSI Codes

ANSI-коды (цвета, жирный текст) сохраняются в лог-файле "как есть". Они видны как escape-последовательности (\e[1m, \e[41;37m и т.д.) при просмотре файла в редакторе или через `cat`. При просмотре через `less -R` или `grep --color=never` можно скрыть или отобразить эти коды.

## Testing

Тестирование проводится через реальный запуск `local-runner.sh`. Проверки:

1. Файл лога создается в директории `./logs/` с корректным таймштампом
2. Файл содержит все выводы: сообщения из lib/logging.sh, выводы модулей, системные сообщения
3. ANSI-коды сохраняются в файле (видимы как `\e[1m`, `\e[41;37m` и т.д.)
4. Терминал продолжает показывать все выводы с цветами (tee дублирует)
5. После завершения скрипта файл лога закрыт и содержит все данные (нет частично записанных строк)

Автоматизированные тесты не требуются: система логирования - это инфраструктурный слой, и её корректность проще проверять вручную через просмотр файла лога и сравнение с терминалом.

Валидация форматного имени файла: `ls ./logs/` показывает файлы в формате `YYYY-MM-DD_HH-MM-SS.log`. Проверка содержимого: `cat ./logs/<файл>.log` показывает те же сообщения, что были в терминале.
