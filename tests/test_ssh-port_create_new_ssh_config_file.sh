#!/usr/bin/env bash
# tests/test_create_new_ssh_config_file.sh
# Тест для функции create_new_ssh_config_file

# Временно отключаем строгий режим выполнения, чтобы избежать прерывания при ошибках
set +e
# Подключаем тестируемый файл (он сам импортирует logging.sh)
source "$(dirname "${BASH_SOURCE[0]}")/../modules/04-ssh-port.sh"
# Возвращаем строгий режим выполнения
set -e

# ==========================================
# НЕОБХОДИМЫЕ ДЛЯ ТЕСТИРОВАНИЯ ПЕРЕМЕННЫЕ
# ==========================================
# Глобальные переменные, используемые в тестируемой функции
# (объявлены как readonly в оригинальном файле, не переопределяем)

# ==========================================
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ТЕСТА
# ==========================================
# Мокирование функций логирования, чтобы избежать лишнего вывода
log_error() {
    : # Ничего не делаем, подавляем вывод
}

log_info() {
    : # Ничего не делаем, подавляем вывод
}

log_success() {
    : # Ничего не делаем, подавляем вывод
}

# Функция для проверки результатов
assertEquals() {
    local expected="$1"
    local actual="$2"
    local message="$3"
    
    if [ "$expected" != "$actual" ]; then
        echo "[X] $message [$expected]/[$actual]"
        return 1
    else
        echo "[V] $message [$expected]/[$actual]"
        return 0
    fi
}

# Функция для проверки существования файла
assertFileExists() {
    local file_path="$1"
    local message="$2"
    
    if [ -f "$file_path" ]; then
        echo "[V] $message [Файл существует]/[Файл существует]"
        return 0
    else
        echo "[X] $message [Файл существует]/[Файл не существует]"
        return 1
    fi
}

# Функция для проверки содержимого файла
assertFileContains() {
    local file_path="$1"
    local expected_content="$2"
    local message="$3"
    
    if grep -q "$expected_content" "$file_path"; then
        echo "[V] $message [Содержит '$expected_content']/[Содержит '$expected_content']"
        return 0
    else
        echo "[X] $message [Содержит '$expected_content']/[Не содержит '$expected_content']"
        return 1
    fi
}

# ==========================================
# ТЕСТЫ ФУНКЦИИ create_new_ssh_config_file
# ==========================================

test_create_new_ssh_config_file_success() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    local test_port="2222"
    local test_config_file="test-ssh-config.conf"
    local test_config_path="$test_dir/$test_config_file"
    
    # Вызываем тестируемую функцию
    create_new_ssh_config_file "$test_port" "$test_dir" "$test_config_file"
    
    # Проверяем результат
    local result=$?
    assertEquals 0 $result "Успешное создание конфигурационного файла"
    
    # Проверяем существование файла
    assertFileExists "$test_config_path" "Файл конфигурации создан"
    
    # Проверяем содержимое файла
    assertFileContains "$test_config_path" "Port $test_port" "Файл содержит правильный порт"
    # Проверяем наличие комментария о генерации (без привязки к точному формату)
    if grep -q "Generated by bsss" "$test_config_path"; then
        echo "[V] Файл содержит комментарий о генерации [Содержит 'Generated by bsss']/[Содержит 'Generated by bsss']"
    else
        echo "[X] Файл содержит комментарий о генерации [Содержит 'Generated by bsss']/[Не содержит 'Generated by bsss']"
    fi
    
    # Очистка с проверкой успешности
    rm -rf "$test_dir" || echo "Предупреждение: не удалось очистить временную директорию $test_dir"
}

test_create_new_ssh_config_file_no_port() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    local test_config_file="test-ssh-config.conf"
    
    # Временно отключаем строгий режим выполнения
    set +e
    # Вызываем тестируемую функцию без порта
    create_new_ssh_config_file "" "$test_dir" "$test_config_file"
    # Сохраняем результат
    local result=$?
    # Возвращаем строгий режим выполнения
    set -e
    
    # Проверяем результат (должен быть код ошибки)
    assertEquals 1 $result "Ошибка при отсутствии порта"
    
    # Очистка с проверкой успешности
    rm -rf "$test_dir" || echo "Предупреждение: не удалось очистить временную директорию $test_dir"
}

test_create_new_ssh_config_file_default_values() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    local test_port="3333"
    
    # Вызываем тестируемую функцию с параметрами по умолчанию
    # (использует значения readonly переменных из оригинального файла)
    create_new_ssh_config_file "$test_port" "$test_dir" "10-bsss-ssh-port.conf"
    
    # Проверяем результат
    local result=$?
    assertEquals 0 $result "Успешное создание файла с параметрами по умолчанию"
    
    # Проверяем существование файла с путем по умолчанию
    local default_config_path="$test_dir/10-bsss-ssh-port.conf"
    assertFileExists "$default_config_path" "Файл создан с путем по умолчанию"
    
    # Очистка с проверкой успешности
    rm -rf "$test_dir" || echo "Предупреждение: не удалось очистить временную директорию $test_dir"
}

test_create_new_ssh_config_file_non_numeric_port() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    local test_config_file="test-ssh-config.conf"
    
    # Временно отключаем строгий режим выполнения
    set +e
    # Вызываем тестируемую функцию с нечисловым портом
    create_new_ssh_config_file "abc" "$test_dir" "$test_config_file"
    # Сохраняем результат
    local result=$?
    # Возвращаем строгий режим выполнения
    set -e
    
    # Проверяем результат (функция вернет 0, так как не проверяет формат порта)
    assertEquals 0 $result "Создание файла с нечисловым портом"
    
    # Проверяем, что файл был создан с нечисловым портом
    local test_config_path="$test_dir/$test_config_file"
    assertFileExists "$test_config_path" "Файл с нечисловым портом создан"
    assertFileContains "$test_config_path" "Port abc" "Файл содержит нечисловый порт"
    
    # Очистка
    rm -rf "$test_dir" || echo "Предупреждение: не удалось очистить временную директорию $test_dir"
}

test_create_new_ssh_config_file_port_out_of_range() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    local test_config_file="test-ssh-config.conf"
    
    # Временно отключаем строгий режим выполнения
    set +e
    # Вызываем тестируемую функцию с портом вне диапазона
    create_new_ssh_config_file "70000" "$test_dir" "$test_config_file"
    # Сохраняем результат
    local result=$?
    # Возвращаем строгий режим выполнения
    set -e
    
    # Проверяем результат (функция вернет 0, так как не проверяет диапазон порта)
    assertEquals 0 $result "Создание файла с портом вне диапазона"
    
    # Проверяем, что файл был создан с портом вне диапазона
    local test_config_path="$test_dir/$test_config_file"
    assertFileExists "$test_config_path" "Файл с портом вне диапазона создан"
    assertFileContains "$test_config_path" "Port 70000" "Файл содержит порт вне диапазона"
    
    # Очистка
    rm -rf "$test_dir" || echo "Предупреждение: не удалось очистить временную директорию $test_dir"
}

test_create_new_ssh_config_file_existing_file() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    local test_config_file="test-ssh-config.conf"
    local test_config_path="$test_dir/$test_config_file"
    
    # Создаем файл заранее
    echo "Existing content" > "$test_config_path"
    
    # Временно отключаем строгий режим выполнения
    set +e
    # Вызываем тестируемую функцию
    create_new_ssh_config_file "2222" "$test_dir" "$test_config_file"
    # Сохраняем результат
    local result=$?
    # Возвращаем строгий режим выполнения
    set -e
    
    # Проверяем результат (функция должна перезаписать файл)
    assertEquals 0 $result "Перезапись существующего файла"
    
    # Проверяем, что файл был перезаписан
    assertFileExists "$test_config_path" "Файл перезаписан"
    assertFileContains "$test_config_path" "Port 2222" "Файл содержит правильный порт после перезаписи"
    
    # Проверяем, что старое содержимое удалено
    if grep -q "Existing content" "$test_config_path"; then
        echo "[X] Старое содержимое удалено [Содержит 'Existing content']/[Не содержит 'Existing content']"
    else
        echo "[V] Старое содержимое удалено [Не содержит 'Existing content']/[Не содержит 'Existing content']"
    fi
    
    # Очистка
    rm -rf "$test_dir" || echo "Предупреждение: не удалось очистить временную директорию $test_dir"
}

# ==========================================
# ЗАПУСК ТЕСТОВ
# ==========================================
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "Запуск тестов для функции create_new_ssh_config_file"
    echo "============================================="
    echo "Формат вывода: [V]/[X] [Описание теста] [Ожидаемый результат]/[Полученный результат]"
    echo "============================================="
    
    test_create_new_ssh_config_file_success
    test_create_new_ssh_config_file_no_port
    test_create_new_ssh_config_file_default_values
    test_create_new_ssh_config_file_non_numeric_port
    test_create_new_ssh_config_file_port_out_of_range
    test_create_new_ssh_config_file_existing_file
    
    echo "============================================="
    echo "Тесты завершены"
fi