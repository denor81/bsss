# Правила написания тестов для bash-функций

## Основные принципы

### 1. Структура тестового файла
- Разделяй код на логические секции с четкими комментариями
- Используй защитную конструкцию `if [[ "${BASH_SOURCE[0]}" == "${0}" ]]` для возможности импорта без выполнения
- Организуй переменные в отдельные блоки по назначению

### 2. Управление переменными
- Определяй только те переменные, которые действительно используются
- Переопределяй переменные через `local` внутри тестовых функций
- Избегай объявления неиспользуемых переменных
- Если переменные используются только в конкретных тестах, определяй их локально

### 3. Написание тестов
- Один тест = одна функция
- Используй `mktemp -d` для создания временных директорий
- Всегда очищай временные ресурсы после теста
- Сохраняй код возврата тестируемой функции в переменную перед проверкой

### 4. Проверка результатов
- Создавай вспомогательные функции для проверки результатов
- Используй унифицированный формат вывода результатов:
  - Для пройденных тестов: `[V] [Краткое описание теста] [Ожидаемый результат]/[Полученный результат]`
  - Для проваленных тестов: `[X] [Краткое описание теста] [Ожидаемый результат]/[Полученный результат]`
- Добавляй в начале теста пояснение формата вывода
- Мокируй функции логирования (`log_error`, `log_info`, `log_success`), чтобы избежать лишнего вывода
- Продолжай выполнение других тестов даже если текущий не пройден

### 5. Изоляция тестов
- Используй `local` для всех переменных внутри тестовых функций
- Мокируй вспомогательные функции, если они могут вызывать побочные эффекты
- Убедись, что тесты не зависят друг от друга

## Частые проблемы и решения

### Проблема: `set -euo pipefail` прерывает выполнение теста
**Решение:** Избегай использования `set -euo pipefail` в тестовых файлах или временно отключай его при вызове тестируемой функции.

### Проблема: Неопределенные переменные вызывают ошибки
**Решение:** Определяй все необходимые переменные перед вызовом тестируемой функции.

### Проблема: Тесты изменяют глобальное состояние
**Решение:** Используй `local` для переопределения глобальных переменных внутри тестов.

### Проблема: Дублирование кода в тестах
**Решение:** Выноси общую логику во вспомогательные функции.

## Чеклист перед завершением теста

- [ ] Все переменные определены в соответствующих секциях
- [ ] Нет дублирования переменных между тестами
- [ ] Используются `local` переменные внутри тестовых функций
- [ ] Временные ресурсы создаются через `mktemp -d`
- [ ] Временные ресурсы очищаются после каждого теста
- [ ] Добавлена защитная конструкция для импорта
- [ ] Тесты можно запускать независимо друг от друга
- [ ] Проверены все граничные случаи
- [ ] Информативные сообщения об ошибках
- [ ] Вспомогательные функции мокированы при необходимости
- [ ] **Проверка на лишний код:** после успешной отладки проверь код на предмет неиспользуемых переменных и лишних функций
- [ ] **Минимализм:** удали весь код, который не используется в тестах
- [ ] **Документация покрытия тестами:** после успешной отладки добавь строку с комментарием над тестируемой функцией в исходном файле с указанием пути к тесту
  - Формат комментария: `# TESTED: tests/path/to/test_file.sh`
  - Комментарий должен находиться непосредственно над определением функции
  - Это позволяет быстро определить, какие функции покрыты тестами

## Пример хорошей структуры теста

```bash
#!/usr/bin/env bash
# tests/test_function_name.sh
# Тест для функции function_name

# Подключаем тестируемый файл
source "$(dirname "${BASH_SOURCE[0]}")/../lib/file_with_function.sh"
# Подключаем зависимости
source "$(dirname "${BASH_SOURCE[0]}")/../lib/dependency.sh"

# ==========================================
# НЕОБХОДИМЫЕ ДЛЯ ТЕСТИРОВАНИЯ ПЕРЕМЕННЫЕ
# ==========================================
# Глобальные переменные, используемые в тестируемой функции
GLOBAL_VAR_1=""
GLOBAL_VAR_2="default_value"

# ==========================================
# ПЕРЕМЕННЫЕ ДЛЯ ФАЙЛА ТЕСТА
# ==========================================
# Переменные, необходимые для работы тестового файла
CURRENT_MODULE_NAME="test_module"

# ==========================================
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ТЕСТА
# ==========================================
# Мокирование функций логирования, чтобы избежать лишнего вывода
log_error() {
    : # Ничего не делаем, подавляем вывод
}

log_info() {
    : # Ничего не делаем, подавляем вывод
}

log_success() {
    : # Ничего не делаем, подавляем вывод
}

# Мокирование вспомогательных функций
helper_function() {
    : # Ничего не делаем в тестах
}

# Функция для проверки результатов
assertEquals() {
    local expected="$1"
    local actual="$2"
    local message="$3"
    
    if [ "$expected" != "$actual" ]; then
        echo "[X] $message [$expected]/[$actual]"
        return 1
    else
        echo "[V] $message [$expected]/[$actual]"
        return 0
    fi
}

# ==========================================
# ТЕСТЫ ФУНКЦИИ function_name
# ==========================================

test_function_name_case_1() {
    # Создаем временную директорию
    local test_dir=$(mktemp -d)
    
    # Переопределяем глобальные переменные для условий теста
    local GLOBAL_VAR_1="$test_dir/some_value"
    
    # Вызываем тестируемую функцию
    function_name
    
    # Проверяем результат
    local result=$?
    assertEquals 0 $result "Описание ожидаемого результата"
    
    # Очистка
    rm -rf "$test_dir"
}

# ==========================================
# ЗАПУСК ТЕСТОВ
# ==========================================
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "Запуск тестов для функции function_name"
    echo "============================================="
    echo "Формат вывода: [V]/[X] [Описание теста] [Ожидаемый результат]/[Полученный результат]"
    echo "============================================="
    
    test_function_name_case_1
    
    echo "============================================="
    echo "Тесты завершены"
fi