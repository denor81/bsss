#######
Спланируй идеальную архитектуру под проект на языке SHELL - этот проект будет называться Basic Server Security Setup (BSSS).
Он будет предназначен для базовой быстрой и легкой настройки безопасности только что установленного сервера Убунту.
Проект будет включать в себя следующий функционал:
1. Проверка файла в системе, который говорит, что система требует перезагрузки - ссобщаем пользователю и выходим.
2. Обновление системы apt update && apt upgrade -y
3. Быстрая и легкая смена SSH порта - данный пункт подразумевает поиск и просмотр файлов конфигурации /etc/ssh/sshd_config и каталога и правил в этом каталоге /etc/ssh/sshd_config.d/NN_rules. Для этого нам нужен доступ. Права root или пользователь в группе sudo. Нам надо найти самое последнее правило, которое является активным и создать новый файл за этим правилом. Например если правило 60-cloudimg-settings.conf и в нем есть настройка Port, то мы создадим новый файл 70-ssh-port-change-bsss.conf, если там нет правила, то создадим 10-ssh-port-change-bsss.conf... Тут еще много нюансов по логике и нужно заранее предусмотреть гибкую, модульную, расширяемую, адаптивную структуру проекта. Еще надо будет выполнять определенные команды после изменения файлов например systemctl daemon-reload, systemctl, restart ssh...
sysctl --system
4. Отключение ipv6 путем добавления правила в GRUB_CMDLINE_LINUX_DEFAULT="ipv6.disable=1" - здесь тоже будет поиск по файлам - /etc/default/grub.d/ и в /etc/default/grub - Само правило добавляется в 10-ipv6-disable-bsss.conf. 
5. Отключение авторизации по паролю (тоже схожая история по поиску файлов и поиску параметра) - нам надо наййти последний по применению файл с правилом - во всех случах мы пишем новый файл с индексом 10-disable-pass-auth-bsss.conf, меняем индекс только в том случае, если в каталоге есть другое правило с искомым параметром и это правило активно и отличается от нужного. Например есть правил 50-some-rule.conf в которром PasswordAuthentication yes активно - тогда мы делаем индекс 60-disable-pass-auth-bsss.conf и устанавливаем PasswordAuthentication no., но в случае если в последнем из файлов установлен PasswordAuthentication no, то это означает, что аутентификация по паролю уже отключена... затем нужно применить настройки systemctl restart ssh
5.1 Данный пункт является объединяющим для пунктов 1,2,3,4,5 - мы не изменяем никакие существующие файлы - мы только добавляем новое правило отдельным файлом, - формат каждой функии , каждого шага/пункта - функция, которая выполняет каждый отдельный шаг должна быть структурирована - нужно создать максимально схожую структуру функций для разных шагов:
5.1.0 Исходные данные для каждго шага - в начале каждой функции прямо в теле функции необходимо прописать исходные данные- например ipv6.disable=1 (параметр, который должен быть активен), адрес клчевых файлов - например dir="/etc/default/grub.d", config="/etc/default/grub". Значения по умаолчанию если есть - ssh_port = 22.
5.1.1 ПРОВЕРКА текущего состояния - например есть файл перезагрузки или нет? Возвращает текущее состояние затем проверяем - При условии "есть" выходим из скрипта. Пример 2 - текущее состояние ipv6 в grub - запускает поиск по основному файлу и файлам с правилами в каталоге grub.d по определенной маске ipv6.disable=... (тут не ясна логика поиска текущего состояния. нужно разработать простую, легкую и одовременно 100% надежную логику для определения текущего состояния)
5.1.2 ФОРМИРОВАНИЕ имени нового файла правила (включает индекс номер, который будет присвоен файлу)
5.1.3 СОЗДАНИЕ и сохранение файла
5.1.4 ПРИМЕНЕНИЕ настроек определенными командами
5.1.5 Каждый шаг должен принимать на вход флаг - check - этот флаг будет означать, что после выполнения проверки шаг прекращает выполнение и возвращает текущее состояние - в сыром виде - ipv6.disable=0 или ipv6.disable=1 или notfound, что означает, что ipv6 включен в случае ipv6. Второй пример с SSH - Port 22 или notfound, что в случае с SSH означает, что порт по умолчанию 22, или третий пример PasswordAuthentication no или PasswordAuthentication yes или notfound, что означает...
5.2 все вспомогательные модули для каждого шага необходимо разложить по каталогам /helpers/ssh/... или /helpers/ipv6/... или /helpers/common/... если создан универсальный.

Важные замечания: 
1. При поиске параметров в конфигурационном файле важно предусмотреть дополнительный модуль, котоорый будет определять активный это параметр или не активный - например Port 22 или #Port 22 - нам надо не просто найти параметр, но и определить активный он или нет. Либо использовать как альтернативу - надежную bash конструкцию, которая ищет Port только с самого начала строки - если найдено, то означает, что параметр есть и он активный. Можно выбрать любой вариант - главное, что бы это было надежно. Предложи варианты на утверждение с описанием плюсов и минусов.
2. Нужно проработать логику и архитектуру поиска и проверки текущего состояния. Предположительно это должен быть отдельный модуль, для каждого шага свой отдельный... хотя это обсуждается и я не уверн, что это оптимальное решение.
2.1 Например при проверке файла для перезагрузки нам нужно знать путь и имя файла и мы можем получить ответ - существует он или нет - это просто.
2.2 в случае с ssh портом нам нужно знать есть ли параметр Port в конфикурационном файле и есть ли в d./ каталоге, активен этот параметр или закомментирован, если этих параметров несколько в разных файлах, то нам надо знать, какой параметр является последним по очереди загрузки - сначала загружается основной файл sshd конфигурации, а потом загружаются файлы из директории .d/ по индексу. только после получения всех этих ответов мы сможем понять что нам нужно делать.
2.3 в случае с ipv6 - ситуация очень похожая - тут надо  проверить наличие ipv6.disable=0 или ipv6.disable=1 (ipv6.disable =0, ipv6.disable= 0, ipv6.disable=  0, и так же с 1 - нужно сжигать пробелы при проверке), если не найдено ничего, то значит ipv6 активени надо добавить параметр в первое правило с индексом 10,  а если найден, то мы придерживаемся правила, что никакие файлы не редактируем, а добавялем новые правила с маркером в имени файла bsss. Тогда тут надо понять ipv6.disable=1 значит уже отключен... тут тоже надо учитывать индекс загрузки и что последнее значение переписывает предыдущее. 
2.4 Похожая ситуация с PasswordAuthentication.
2.5 Возможно нам сначала придется создать  каталоги со всеми возможными вариантами для каждого случая test/etc/ssh/sshd_config (существует), но sshd_config.d/ (не существует) /// sshd_config (существует), sshd_config.d/ (существует, но пустой) /// sshd_config (существует), sshd_config.d/ (существует, и есть несколько правил/ и есть одно правило....) и далее и далее. И потому написать тесты для всех этиих каталогов и потом уже приступить к написанию кода... На первый взгляд задача казалось простой, но оказалось очень много нюансов.

Сейчас надо доработать данное ТЗ на разработку архитектуры проекта.
Нам нужно обдумать, затем определиться и затем грамотно прописать все нюансы выбранного варианта определения активного параметра в последнем по очереди загрузи файле и предусмотреть все варианты развития событий включая крайние случаи. 
Текущая задача тебя, как архитектора - не создавать архитектуру, а доработать данное ТЗ, что бы оно было полным и не имело пробелов и пустошей. Нужно обдумать и проработать все возможные тонкие места и пустые пробелы в этом ТЗ.
Твоя задача пронализировать и составить список тонких мест - работаем в форме интервью - задавай вопросы, которые нужно обговорить и предлагай варианты решений, что бы выбрать.

Не переписывай мое ТЗ - просто задавай вопросы и собирай информацию для уточнения. После завершения интервью я попрошу тебя переписать ТЗ. Сейчас заполняем пробелы и ищем решения

#################
Сейчас нужно создать грамотную архитектуру, что бы было легко адаптировать и расширять пакет, добавлять новый функционал, как модули. Архитектура должна поддерживать легкое интегрирование новых фич/модулей. Запуск планируется через wget или curl, без установки, как таковой. Язык исключительно SHELL.

Создай ТЗ по архитектуре с шаблоном каталогов и описанием, что где будет храниться. Создай файл md в корне проекта - этот файл будет использован при написании проекта.

Ознакомься с лучшими практиками по написанию кода на SHELL это может пригодиться при составлении архитектуры - в катаоге /BEST_PRACTIES/SHELL.md и првилами написнания кода в CLAUDE.md

Важно! Первое, что необходимо сделать это составить список вопросов по данному ТЗ - предварительно провести опрос пользователя. Задать вопросы по каждому не явному аспекту, касающегося Архитектуры написания проекта. Опросить пользователя по не уточненным аспектам, опросить по неоднозначным аспектам. При опросе пользователя предлагать вариант наилучшего ответа на вопрос с точки зрения правильной Архитектуры проекта и предложить альтернативу, либо дать возможность пользователю описать данный аспект своими словами.



####
Я продублирую тебе все нашишаги обсуждения, что бы напомнить и прошу тебя написать в формате md ТЗ со всеми обсужденными пунктами. 

Мое первое ТЗ - сырой вариант
###
Спланируй идеальную архитектуру под проект на языке SHELL - этот проект будет называться Basic Server Security Setup (BSSS).
Он будет предназначен для базовой быстрой и легкой настройки безопасности только что установленного сервера Убунту.
Проект будет включать в себя следующий функционал:
1. Проверка файла в системе, который говорит, что система требует перезагрузки - ссобщаем пользователю и выходим.
2. Обновление системы apt update && apt upgrade -y
3. Быстрая и легкая смена SSH порта - данный пункт подразумевает поиск и просмотр файлов конфигурации /etc/ssh/sshd_config и каталога и правил в этом каталоге /etc/ssh/sshd_config.d/NN_rules. Для этого нам нужен доступ. Права root или пользователь в группе sudo. Нам надо найти самое последнее правило, которое является активным и создать новый файл за этим правилом. Например если правило 60-cloudimg-settings.conf и в нем есть настройка Port, то мы создадим новый файл 70-ssh-port-change-bsss.conf, если там нет правила, то создадим 10-ssh-port-change-bsss.conf... Тут еще много нюансов по логике и нужно заранее предусмотреть гибкую, модульную, расширяемую, адаптивную структуру проекта. Еще надо будет выполнять определенные команды после изменения файлов например systemctl daemon-reload, systemctl, restart ssh...
sysctl --system
4. Отключение ipv6 путем добавления правила в GRUB_CMDLINE_LINUX_DEFAULT="ipv6.disable=1" - здесь тоже будет поиск по файлам - /etc/default/grub.d/ и в /etc/default/grub - Само правило добавляется в 10-ipv6-disable-bsss.conf. 
5. Отключение авторизации по паролю (тоже схожая история по поиску файлов и поиску параметра) - нам надо наййти последний по применению файл с правилом - во всех случах мы пишем новый файл с индексом 10-disable-pass-auth-bsss.conf, меняем индекс только в том случае, если в каталоге есть другое правило с искомым параметром и это правило активно и отличается от нужного. Например есть правил 50-some-rule.conf в которром PasswordAuthentication yes активно - тогда мы делаем индекс 60-disable-pass-auth-bsss.conf и устанавливаем PasswordAuthentication no., но в случае если в последнем из файлов установлен PasswordAuthentication no, то это означает, что аутентификация по паролю уже отключена... затем нужно применить настройки systemctl restart ssh
5.1 Данный пункт является объединяющим для пунктов 1,2,3,4,5 - мы не изменяем никакие существующие файлы - мы только добавляем новое правило отдельным файлом, - формат каждой функии , каждого шага/пункта - функция, которая выполняет каждый отдельный шаг должна быть структурирована - нужно создать максимально схожую структуру функций для разных шагов:
5.1.0 Исходные данные для каждго шага - в начале каждой функции прямо в теле функции необходимо прописать исходные данные- например ipv6.disable=1 (параметр, который должен быть активен), адрес клчевых файлов - например dir="/etc/default/grub.d", config="/etc/default/grub". Значения по умаолчанию если есть - ssh_port = 22.
5.1.1 ПРОВЕРКА текущего состояния - например есть файл перезагрузки или нет? Возвращает текущее состояние затем проверяем - При условии "есть" выходим из скрипта. Пример 2 - текущее состояние ipv6 в grub - запускает поиск по основному файлу и файлам с правилами в каталоге grub.d по определенной маске ipv6.disable=... (тут не ясна логика поиска текущего состояния. нужно разработать простую, легкую и одовременно 100% надежную логику для определения текущего состояния)
5.1.2 ФОРМИРОВАНИЕ имени нового файла правила (включает индекс номер, который будет присвоен файлу)
5.1.3 СОЗДАНИЕ и сохранение файла
5.1.4 ПРИМЕНЕНИЕ настроек определенными командами
5.1.5 Каждый шаг должен принимать на вход флаг - check - этот флаг будет означать, что после выполнения проверки шаг прекращает выполнение и возвращает текущее состояние - в сыром виде - ipv6.disable=0 или ipv6.disable=1 или notfound, что означает, что ipv6 включен в случае ipv6. Второй пример с SSH - Port 22 или notfound, что в случае с SSH означает, что порт по умолчанию 22, или третий пример PasswordAuthentication no или PasswordAuthentication yes или notfound, что означает...
5.2 все вспомогательные модули для каждого шага необходимо разложить по каталогам /helpers/ssh/... или /helpers/ipv6/... или /helpers/common/... если создан универсальный.

Важные замечания: 
1. При поиске параметров в конфигурационном файле важно предусмотреть дополнительный модуль, котоорый будет определять активный это параметр или не активный - например Port 22 или #Port 22 - нам надо не просто найти параметр, но и определить активный он или нет. Либо использовать как альтернативу - надежную bash конструкцию, которая ищет Port только с самого начала строки - если найдено, то означает, что параметр есть и он активный. Можно выбрать любой вариант - главное, что бы это было надежно. Предложи варианты на утверждение с описанием плюсов и минусов.
2. Нужно проработать логику и архитектуру поиска и проверки текущего состояния. Предположительно это должен быть отдельный модуль, для каждого шага свой отдельный... хотя это обсуждается и я не уверн, что это оптимальное решение.
2.1 Например при проверке файла для перезагрузки нам нужно знать путь и имя файла и мы можем получить ответ - существует он или нет - это просто.
2.2 в случае с ssh портом нам нужно знать есть ли параметр Port в конфикурационном файле и есть ли в d./ каталоге, активен этот параметр или закомментирован, если этих параметров несколько в разных файлах, то нам надо знать, какой параметр является последним по очереди загрузки - сначала загружается основной файл sshd конфигурации, а потом загружаются файлы из директории .d/ по индексу. только после получения всех этих ответов мы сможем понять что нам нужно делать.
2.3 в случае с ipv6 - ситуация очень похожая - тут надо  проверить наличие ipv6.disable=0 или ipv6.disable=1 (ipv6.disable =0, ipv6.disable= 0, ipv6.disable=  0, и так же с 1 - нужно сжигать пробелы при проверке), если не найдено ничего, то значит ipv6 активени надо добавить параметр в первое правило с индексом 10,  а если найден, то мы придерживаемся правила, что никакие файлы не редактируем, а добавялем новые правила с маркером в имени файла bsss. Тогда тут надо понять ipv6.disable=1 значит уже отключен... тут тоже надо учитывать индекс загрузки и что последнее значение переписывает предыдущее. 
2.4 Похожая ситуация с PasswordAuthentication.
2.5 Возможно нам сначала придется создать  каталоги со всеми возможными вариантами для каждого случая test/etc/ssh/sshd_config (существует), но sshd_config.d/ (не существует) /// sshd_config (существует), sshd_config.d/ (существует, но пустой) /// sshd_config (существует), sshd_config.d/ (существует, и есть несколько правил/ и есть одно правило....) и далее и далее. И потому написать тесты для всех этиих каталогов и потом уже приступить к написанию кода... На первый взгляд задача казалось простой, но оказалось очень много нюансов.

Сейчас надо доработать данное ТЗ на разработку архитектуры проекта.
Нам нужно обдумать, затем определиться и затем грамотно прописать все нюансы выбранного варианта определения активного параметра в последнем по очереди загрузи файле и предусмотреть все варианты развития событий включая крайние случаи. 
Текущая задача тебя, как архитектора - не создавать архитектуру, а доработать данное ТЗ, что бы оно было полным и не имело пробелов и пустошей. Нужно обдумать и проработать все возможные тонкие места и пустые пробелы в этом ТЗ.
Твоя задача пронализировать и составить список тонких мест - работаем в форме интервью - задавай вопросы, которые нужно обговорить и предлагай варианты решений, что бы выбрать.

Не переписывай мое ТЗ - просто задавай вопросы и собирай информацию для уточнения. После завершения интервью я попрошу тебя переписать ТЗ. Сейчас заполняем пробелы и ищем решения
###

Первая итерация обсуждения
###
ВОПРОСЫ:
Отличный проект! Давайте вместе проработаем все тонкие места. Я буду задавать вопросы по каждому проблемному месту и предлагать варианты решений для обсуждения.

## Вопросы по архитектуре и логике:

### 1. **Определение активного параметра в конфигурационных файлах**

**Проблема:** Как надежно определить, активен ли параметр и какое значение действительно применяется?

**Варианты решения:**
- **Вариант A:** Поиск по регулярным выражениям (только некомментированные строки)
- **Вариант B:** Использование `sshd -T` для SSH параметров (выводит фактическую конфигурацию)
- **Вариант C:** Парсинг с игнорированием комментариев и пустых строк

**Вопрос:** Какой подход предпочтительнее? Например для SSH:
- `sshd -T | grep -i "port"` покажет реальный порт
- Но это требует прав root и может быть "тяжелее"

### 2. **Приоритет загрузки конфигурационных файлов**

**Проблема:** В каком порядке обрабатывать файлы для определения последнего активного правила?

**Вопрос:** Правильно ли я понимаю логику приоритетов:
1. Основной файл (`sshd_config`, `grub`)
2. Файлы в `.d/` директориях в **алфавитном** порядке (00-, 10-, 50-)
3. Последнее найденное активное правило побеждает

### 3. **Логика определения индекса для нового файла**

**Проблема:** Как генерировать индекс для нового файла правила?

**Пример с SSH портом:**
- Нашли активный `Port` в `50-cloudimg.conf` → создаем `60-bsss-ssh-port.conf`
- Не нашли активного `Port` → создаем `10-bsss-ssh-port.conf`

**Вопрос:** Что делать если:
- Есть несколько файлов с нашим маркером `bsss`?
- Индекс должен быть всегда выше максимального найденного или может быть фиксированным?

### 4. **Структура возвращаемых значений для проверки состояния**

**Проблема:** Как унифицировать возвращаемые значения для разных типов параметров?

**Вопрос:** Нужна ли унифицированная структура для всех проверок?
```
ssh_port: "22" | "2222" | "notfound"
ipv6_state: "enabled" | "disabled" | "notfound" 
password_auth: "yes" | "no" | "notfound"
```

### 5. **Обработка пробелов и форматов параметров**

**Проблема:** Параметры могут быть в разных форматах:
- `Port 22`
- `Port    22`
- `Port=22`
- `Port = 22`

**Вопрос:** Нужно ли нормализовать все к одному формату или искать все варианты?

### 6. **Безопасность и откат изменений**

**Проблема:** Что если скрипт прервется посередине?

**Вопрос:** Нужно ли:
- Создавать backup файлов перед изменением?
- Реализовать механизм отката?
- Добавить проверку валидности конфигурации перед применением?

### 7. **Взаимодействие между шагами**

**Проблема:** Некоторые шаги могут конфликтовать или зависеть друг от друга.

**Вопрос:** Например:
- При смене SSH порта нужно проверять, что брандмауэр разрешает новый порт?
- Нужна ли проверка, что пользователь не заблокирует себе доступ?

### 8. **Обработка ошибок и крайних случаев**

**Вопрос:** Как обрабатывать:
- Отсутствующие директории (`/etc/ssh/sshd_config.d/`)
- Файлы без прав на запись
- Некорректные значения параметров
- Системы без systemd

### 9. **Тестирование и валидация**

**Вопрос:** Нужно ли создать:
- Mock окружения для тестирования?
- Валидацию вводимых пользователем значений (например, валидный SSH порт)?
- Проверку примененных изменений?

### 10. **Архитектура вспомогательных модулей**

**Вопрос:** Какие общие функции можно выделить?
- Поиск параметра в иерархии файлов
- Определение активного/неактивного параметра
- Генерация индекса для нового файла
- Применение изменений с проверкой

### 11. **Производительность и оптимизация**

**Вопрос:** Нужно ли кэшировать результаты проверок между шагами?
Например, один раз просканировать SSH конфигурацию для всех SSH-связанных шагов.

### 12. **Логирование и отчетность**

**Вопрос:** Какая информация должна логироваться:
- Только ошибки?
- Все предпринятые действия?
- Состояние "до" и "после" для каждого шага?

---

ОТВЕТЫ:
1.
Вариант A: Поиск по регулярным выражениям (только некомментированные строки)

2.
Вопрос: Правильно ли я понимаю логику приоритетов:
Основной файл (sshd_config, grub)
Файлы в .d/ директориях в алфавитном порядке (00-, 10-, 50-)
Последнее найденное активное правило побеждает
Все верно - понимаешь верно.

3.
Нашли активный Port в 50-cloudimg.conf → создаем 60-bsss-ssh-port.conf
Не нашли активного Port → создаем 10-bsss-ssh-port.conf
Все верно, на счет если содержиится файл bsss (по задумке может содержаться только один файл bsss - будет реализована функция возврата к начальным настройкам - это будет подразумевать, что надо удалить файл bsss и применить обновление настроек. Если же файл bsss уже содержится, то найденная в нем настройка будет активной и по идее новый файл ни при каких обстоятельства не может быть создан, потому что найдена активная настройка- она посленяя по индексу - то есть параметр настроен верно. Но если по какой то причине фалй bsss уже есть и имеет индекс 10 ,а в каталоге есть еще правило 50 и там тоже активня настройка, то нам по идее над создавать файл с индексом 60 - а файл 10 с маркером bsss нужно удалить.

4. Структура возвращаемых значений для проверки состояния
Унифицировать не нужно - в каждом шаге будет свой обработчик/парсер, который будет ожидать определенные возможные ответы и сам решать, как быть дальше. Даже еще проще - не надо приводить к значению "enabled" | "disabled" | "notfound"  - нужно возвращать удовлетворившую условиям строку целиком и название файла в абсолютном виде. Два значения. Далее каждый шаг будет сам разбираться.

5. Обработка пробелов и форматов параметров
Такая же ситуация, как и с 4 шагом - строку целиком возвращаем.

6. Безопасность и откат изменений
в ТЗ есть описание маркера check - это будет 0 этап - при запуске скрипта будет опрошен каждый шаг и получен ответ с текущим состоянием - это и будет своего рода проверка валиности. Каждый обработчик будет иметь свои обработчики ошибок и при ошибках будет возвращать в подготовительный этап undefined/notfound или подобное значение, а при грубых ошибках прекращать выполнение скрипта на этапе запуска и проверки check.  Данный ша будет своего рода валидатором и подготовительным этапом, что бы удостовериться, что скрипт сработает правильно хотя в области путей и файлов Эта информация будет отображена пользователю. Backup - это удаление файлов с маркером bsss в каталогах d./ и применение настроек.

7. Взаимодействие между шагами
Верное замечание на счет файрвола и бандмауэер.
Мы предполагаем, что на клиенте пользователь сам разберется, как открыть нужный порт. Никаких проверок не будем проводить. Но на стороне системы, где работает скрипт - нужно выполнить проверку на открытые порты ufw... В ТЗ Будет добавлен пункт с активацией UFW. Этот пункт так же надо добавить в ТЗ. При этом если произошла успешная смена порта SSH - при активации ufw на последующих шагах - новый порт должен быть добавлен в разрешенные, а остальные порты закрыть. Или например скрипт запускается повторно, но при предыдущем запуске был просто сменен порт ssh а файрволл не активирован, то сейчас мы пропускаем все шаги и доходим до ufw файрвола и активируем его (не меняя в этом запуске скрипта ssh порт - то текущий порт должен все равно подставлять в файрволл. - то еть я так понимаю надо запускать из шага с установкой файрвола - запускать шаг смены порта ssh с меткой check - что бы получить текущий порт и при активации его открыть. вот такая команда закрывает все порты ufw enable && ufw allow OpenSSH && ufw allow 18772/tcp и открывает один. - при этом если мы хотим отключить фарволл - то скрипт выполняет отключение файрвола с доп командой о сбросе - что бы ufw полностью сбрасывался.

8. Обработка ошибок и крайних случаев
если директории нет - мы ее создаем при создании файла настроек
Файлы без прав на запись - данную проверку нужно производить на этапе check и останавливать выполнение скрипта.
Некорректные значения параметров - этот функционал будет реализован непосредственно в функциях шагах - в каждой функции по своему.
Системы без systemd - я не слышал о таких, но сейчас погуглил и нашел, что да есть - я ориентируюсь только на убунту с последующей доработкой для дебиан. Системы без systemd не будут поддерживаться - выход из скрипта.

9. Тестирование и валидация
Mock окружения для тестирования? - нам надо создать каталоги, как я и писал в ТЗ со всеми вариантами возможных событий - где то есть каталог .d/ , где то нет, где то есть правила в этом каталоге, где то нет, где то файлы есть но нет параметров.... и затем тестировать все варианты этих замоканых окружений.
Проверку примененных изменений? - проверку не добавляем. Возможно в будущем. Запиши в TODO

10. Архитектура вспомогательных модулей
не могу определиться пока не пойму какие итоговые хелперы будут сформированы - запиши в TODO перепроверить и отрефакторить.

11. Производительность и оптимизация
Кеширование наоборот не нужно. оно запутает. Без кеширования.

12. Логирование и отчетность
Нужен флаг запуска -v  для логирования всех предпринятых шагов - для этого нужно создать модуль логирования, который будет поддерживать этот флаг, а без флага по умолчанию логировать только состояния до и после.

проанализируй мои ответы и сопоставь их с моим ТЗ - задай вопросы повторно в случае если есть критически важные не обговоренные места, которые могут навредить созанию грамотной архитектуры. Если все ок - просто напиши КРАТКОЕ саммари, что мы сделали и я подумаю или дополню или порошу создать обновленное ТЗ
###

Вторая итерация обсуждения
###
ВОПРОСЫ:
## Критически важные необговоренные места:

### 1. **Механизм определения активного параметра в иерархии файлов**
**Проблема:** Недостаточно ясен алгоритм поиска "последнего активного правила"
```bash
# Как именно будем обрабатывать эту последовательность?
00-first.conf:  #Port 22
50-second.conf: Port 2222  
60-third.conf:  #Port 3333
# Какое значение считается активным? 2222 или дефолтное 22?
```

### 2. **Конфликт между существующими файлами bsss**
**Проблема:** Что если уже есть файл `10-bsss-ssh.conf`, но появилось новое правило `50-cloud.conf` с другим значением?
- Удалять старый bsss файл автоматически?
- Предупреждать пользователя?
- Создавать новый с более высоким индексом?

### 3. **Валидация пользовательского ввода для SSH порта**
**Проблема:** Нет спецификации проверок:
- Диапазон портов (1-65535)
- Не системные порты (>1024)
- Не занят ли порт другими сервисами
- Корректность синтаксиса

### 4. **Взаимные блокировки между шагами**
**Проблема:** Порядок выполнения критически важен:
```bash
# Неправильный порядок:
1. Сменить SSH порт
2. Активировать UFW (заблокирует старый порт)
3. Разрешить новый порт в UFW # Уже поздно!

# Правильный порядок:
1. Сменить SSH порт
2. Разрешить новый порт в UFW  
3. Активировать UFW
```

### 5. **Обработка частичного сбоя**
**Проблема:** Что если скрипт упадет на шаге 4 из 5?
- Оставляем систему в половинчатом состоянии?
- Нужен ли механизм "отката до предыдущего стабильного состояния"?

ОТВЕТЫ:
# Как именно будем обрабатывать эту последовательность?
00-first.conf:  #Port 22
50-second.conf: Port 2222  
60-third.conf:  #Port 3333
# Какое значение считается активным? 2222 или дефолтное 22? здесь активным является 2222 - индекс файлов по возрастанию.
2. Конфликт между существующими файлами bsss - мы проверяем и пишем, что текущий порт 33, он установлен в новом файле 50-cloud.conf и даже если ранее мы установили 32 в 10-bsss-ssh.conf - то пользователь выидит, что текущий 33 и все. есл пользователь хочет сменить порт на 35, то старый/старые файл(ы) с меткой bsss удаляются и создается новый с нужным индексом. если у нас 50-cloud.conf (33) и 60-bsss-ssh.conf (32) и пользователь меняет порт на 35 - мы не создаем новый 70-bsss-ssh.conf, а удаляем 60-bsss-ssh.conf (32) и создаем новый 60-bsss-ssh.conf (35). Если пользователь захочет воспользоваться backup функцией (она запускается по флагу --default и дступна только тем функциям, которые поддерживают этот флаг - то есть если запустить без этого флага - то все шаги будут запущены, а если запустить с этим флагом - то выполянться будут только шаги, котрые поддерживают этот флаг) так вот, если запустить с default - то просто удалются все файлы с меткой bsss и применяются настройки.


3. Валидация пользовательского ввода для SSH порта
Валидацию нужна и нужно вынести ее в отдельный хелпер - пока в этом хелпере должна быть проверка от 1 до 65535. и добавь в TODO проверку на свободность порта.

# Правильный порядок:
1. Сменить SSH порт
2. Разрешить новый порт в UFW  
3. Активировать UFW
Все верно - шаги важны и порядок такой

5. Обработка частичного сбоя пока нет  добавь в TODO - Подумать

проанализируй мои ответы и сопоставь их с моим ТЗ - задай вопросы повторно в случае если есть критически важные не обговоренные места, которые могут навредить созанию грамотной архитектуры. Если все ок - просто напиши КРАТКОЕ саммари, что мы сделали и я подумаю или дополню или порошу создать обновленное ТЗ

###


Итоговое ТЗ. Учитывать весь контекст переписки, что бы не упустить детали.
# Техническое задание: Basic Server Security Setup (BSSS)

## 1. Общие сведения

### 1.1. Назначение
Скрипт для базовой быстрой и легкой настройки безопасности только что установленного сервера Ubuntu.

### 1.2. Требования к системе
- Операционная система: Ubuntu (с поддержкой systemd)
- Права: root или пользователь в группе sudo

### 1.3. Основные принципы
- Не изменять существующие конфигурационные файлы, а добавлять правила в отдельные файлы в директориях `.d`
- Каждый шаг имеет единую структуру функции
- Использование маркера `bsss` в именах файлов для идентификации правил, добавленных скриптом

## 2. Функциональные требования

### 2.1. Шаг 1: Проверка необходимости перезагрузки
- **Цель**: Проверить наличие файла, указывающего на необходимость перезагрузки системы.
- **Действие**: Если файл существует, сообщить пользователю и завершить выполнение скрипта.

### 2.2. Шаг 2: Обновление системы
- **Цель**: Обновить пакеты системы.
- **Команда**: `apt update && apt upgrade -y`

### 2.3. Шаг 3: Смена SSH порта
- **Цель**: Изменить порт SSH на указанный пользователем.
- **Конфигурационные файлы**:
  - Основной: `/etc/ssh/sshd_config`
  - Директория с правилами: `/etc/ssh/sshd_config.d/`
- **Логика**:
  - Поиск последнего активного правила `Port` в иерархии файлов (основной файл и файлы в `.d` в алфавитном порядке).
  - Если активное правило найдено и значение совпадает с желаемым, ничего не делать.
  - Если активное правило найдено, но значение отличается, удалить все существующие файлы `bsss` для SSH порта и создать новый файл с индексом, превышающим индекс файла с последним активным правилом.
  - Если активное правило не найдено, создать файл с индексом `10`.
- **Валидация ввода**:
  - Проверка диапазона портов: 1-65535.
  - TODO: Проверка занятости порта.
- **Применение изменений**: `systemctl daemon-reload && systemctl restart ssh`

### 2.4. Шаг 4: Отключение IPv6
- **Цель**: Добавить параметр `ipv6.disable=1` в командную строку ядра.
- **Конфигурационные файлы**:
  - Основной: `/etc/default/grub`
  - Директория с правилами: `/etc/default/grub.d/`
- **Логика**:
  - Поиск последнего активного правила `ipv6.disable` в иерархии файлов.
  - Если активное правило `ipv6.disable=1` уже установлено, ничего не делать.
  - Если активное правило `ipv6.disable=0` или не найдено, удалить все существующие файлы `bsss` для IPv6 и создать новый файл с соответствующим индексом.
- **Применение изменений**: `update-grub`

### 2.5. Шаг 5: Отключение авторизации по паролю для SSH
- **Цель**: Установить `PasswordAuthentication no`.
- **Конфигурационные файлы**:
  - Основной: `/etc/ssh/sshd_config`
  - Директория с правилами: `/etc/ssh/sshd_config.d/`
- **Логика**:
  - Поиск последнего активного правила `PasswordAuthentication` в иерархии файлов.
  - Если активное правило `PasswordAuthentication no` уже установлено, ничего не делать.
  - Если активное правило `PasswordAuthentication yes` или не найдено, удалить все существующие файлы `bsss` для этого параметра и создать новый файл с индексом, превышающим индекс файла с последним активным правилом.
- **Применение изменений**: `systemctl restart ssh`

### 2.6. Шаг 6: Настройка UFW (брандмауэра)
- **Цель**: Активировать UFW и настроить правила для SSH.
- **Зависимости**: Требует знания текущего SSH порта (из шага 3).
- **Логика**:
  - Разрешить текущий SSH порт (полученный из шага 3 в режиме `check`).
  - Активировать UFW, запретив все входящие соединения по умолчанию и разрешив только SSH порт.
- **Команды**:
  - `ufw enable`
  - `ufw allow <ssh_port>/tcp`
  - `ufw default deny incoming`

## 3. Архитектура

### 3.1. Структура функций каждого шага

Каждая функция шага должна иметь следующую структуру:

```bash
function step_name() {
    # 3.1.0. Исходные данные
    local parameter="value"
    local dir="/path/to/config/d"
    local config="/path/to/main/config"
    local default_value="default"

    # 3.1.1. Проверка текущего состояния
    # Возвращает: 
    #   - строку параметра (найденную в конфигурации) и абсолютный путь к файлу
    #   или "notfound", если параметр не найден
    local current_state=$(check_current_state)

    # 3.1.2. Формирование имени нового файла правила
    # На основе последнего активного правила определяет индекс и имя файла
    local new_filename=$(generate_new_filename)

    # 3.1.3. Создание и сохранение файла
    create_config_file "$new_filename" "$parameter"

    # 3.1.4. Применение настроек
    apply_settings
}
```

### 3.2. Режим проверки (check)

Каждый шаг должен поддерживать флаг `check`, при котором:
- Выполняется только проверка текущего состояния (п.3.1.1)
- Возвращается сырое значение параметра и файл, или "notfound"
- Скрипт не вносит изменений

### 3.3. Вспомогательные модули

Организация хелперов по каталогам:
- `/helpers/ssh/` - для шагов, связанных с SSH
- `/helpers/ipv6/` - для шага отключения IPv6
- `/helpers/ufw/` - для настройки брандмауэра
- `/helpers/common/` - общие функции

### 3.4. Определение активного параметра

- **Метод**: Поиск по регулярным выражениям (только некомментированные строки)
- **Регулярное выражение**: `^\\s*Port\\s+\\d+` (пример для SSH порта)
- **Алгоритм поиска**:
  1. Обход файлов в порядке: основной конфиг, затем файлы в `.d` в алфавитном порядке.
  2. В каждом файле ищется последнее некомментированное вхождение параметра.
  3. Из всех найденных параметров активным считается последний по порядку файлов.

### 3.5. Генерация индекса для нового файла

- Если активный параметр найден в файле с индексом `NN`, то новый файл создается с индексом `NN+10`.
- Если активный параметр не найден, используется индекс `10`.
- Имя файла включает маркер `bsss` и название параметра, например: `60-bsss-ssh-port.conf`.

### 3.6. Обработка существующих файлов bsss

- При изменении настроек все старые файлы с маркером `bsss` для данного параметра удаляются.
- Создается новый файл с актуальным индексом.

## 4. Флаги командной строки

- `--check`: Режим проверки - выполнение всех шагов в режиме проверки без внесения изменений.
- `--default`: Режим отката - удаление всех файлов с маркером `bsss` и применение настроек.
- `-v`: Подробный вывод (логирование всех действий).

## 5. Обработка ошибок и крайние случаи

- Проверка прав на запись в конфигурационные директории на этапе `check`.
- Если директория `.d` не существует, она создается при создании файла настроек.
- Некорректные значения параметров обрабатываются в каждом шаге индивидуально.
- При отсутствии systemd скрипт завершается с ошибкой.

## 6. Тестирование

- Создание mock окружений для тестирования всех возможных сценариев:
  - Существование и отсутствие директорий `.d`
  - Различные комбинации конфигурационных файлов
  - Наличие и отсутствие параметров
- Тестирование порядка применения правил.

## 7. Логирование

- Без флага `-v`: логирование состояний "до" и "после" для каждого шага.
- С флагом `-v`: подробное логирование всех предпринятых действий.

## 8. TODO

- Реализовать проверку занятости SSH порта.
- Продумать механизм обработки частичного сбоя (откат изменений при прерывании скрипта).
- Рефакторинг вспомогательных модулей после реализации.

## 9. Порядок выполнения шагов

1. Проверка перезагрузки
2. Обновление системы
3. Смена SSH порта
4. Отключение IPv6
5. Отключение авторизации по паролю
6. Настройка UFW

Важно: Шаг 6 (UFW) должен выполняться после шага 3 (SSH порт) и использовать текущий SSH порт, полученный из шага 3.
####


Сейчас нужно создать грамотную архитектуру, что бы было легко адаптировать и расширять пакет, добавлять новый функционал, как модули. Архитектура должна поддерживать легкое интегрирование новых фич/модулей. Запуск планируется через wget или curl, без установки, как таковой. Язык исключительно SHELL.

Ознакомься с лучшими практиками по написанию кода на SHELL это может пригодиться при составлении архитектуры - в катаоге /BEST_PRACTIES/SHELL.md и првилами написнания кода в CLAUDE.md

Скрипт будет работать в интерактивном режиме последовательно (шаг за шагом) и ожидать ответа от пользователя - при односложныйх ответах достпные варианты Y/n, где Y по умолчанию. Можно нажать Enter и сработает Y., При смене порта требуется проверка на корректность ввода - это должно быть число от 1 до 65535. пробелы сжигать.

Задавай вопросы и предлагай самые оптимальные варианты ответов на вопросы не затронутые в данном ТЗ. Если все понятно просто пиши код строго следуя проекту.
