# Ключевые архитектурные решения BSSS

## 1. Решения по структуре проекта

### 1.1. Модульная архитектура с загрузчиком
**Решение:** Использовать модульную архитектуру с загрузчиком (launcher.sh) и системой кеширования

**Обоснование:**
- Обеспечивает работу в режиме one-line команды через wget/curl
- Снижает нагрузку на сеть при повторных запусках
- Позволяет легко обновлять отдельные модули
- Сохраняет портативность без необходимости установки

**Альтернативы рассмотрены:**
- Монолитный скрипт: сложно обновлять, больше размер
- Установка через пакетный менеджер: требует прав, не универсально

### 1.2. Децентрализованная обработка ошибок
**Решение:** Каждый модуль самостоятельно обрабатывает свои ошибки

**Обоснование:**
- Упрощает разработку и отладку отдельных модулей
- Позволяет специализировать обработку ошибок под каждый модуль
- Избегает сложной централизованной системы обработки ошибок

**Альтернативы рассмотрены:**
- Централизованный обработчик: сложнее в реализации, больше связей

## 2. Решения по управлению состоянием

### 2.1. Глобальные переменные для межмодульного взаимодействия
**Решение:** Использовать глобальные переменные для хранения состояния между шагами

**Обоснование:**
- Простота реализации
- Явное определение зависимостей между модулями
- Легкость отладки состояния системы

**Альтернативы рассмотрены:**
- Временные файлы: медленнее, требует очистки
- Функции-геттеры: сложнее в реализации, возможна рекурсия

### 2.2. Унифицированная структура модулей
**Решение:** Все модули следуют единой структуре с функциями check, default, normal

**Обоснование:**
- Упрощает понимание и разработку новых модулей
- Обеспечивает консистентность поведения
- Упрощает автоматическое тестирование

## 3. Решения по взаимодействию с пользователем

### 3.1. Простой текстовый интерфейс
**Решение:** Использовать текстовый интерфейс с Y/n подтверждениями

**Обоснование:**
- Максимальная совместимость без дополнительных зависимостей
- Простота реализации
- Работает в любой SSH сессии

**Альтернативы рассмотрены:**
- whiptail/dialog: требует установки, может отсутствовать
- GUI: не подходит для серверного использования

### 3.2. Валидация ввода на стороне клиента
**Решение:** Проверять корректность ввода непосредственно в момент ввода

**Обоснование:**
- Мгновенная обратная связь для пользователя
- Снижение количества ошибочных сценариев
- Упрощение логики обработки в модулях

## 4. Решения по работе с конфигурациями

### 4.1. Поиск активного параметра в иерархии файлов
**Решение:** Алгоритм поиска последнего активного параметра с учетом порядка загрузки

**Обоснование:**
- Корректно обрабатывает приоритеты конфигураций
- Надежно определяет фактически применяемые настройки
- Поддерживает существующие практики конфигурации Ubuntu

**Алгоритм:**
1. Проверка основного конфигурационного файла
2. Проверка файлов в .d директории в алфавитном порядке
3. Последнее найденное активное правило считается действующим

### 4.2. Создание файлов с индексом
**Решение:** Генерация индекса для новых файлов на основе последнего активного правила

**Обоснование:**
- Обеспечивает правильный порядок применения правил
- Позволяет легко определять приоритет
- Соответствует стандартным практикам конфигурации

**Логика:**
- Если активное правило найдено в файле с индексом NN, новый файл создается с индексом NN+10
- Если активное правило не найдено, используется индекс 10
- Имя файла включает маркер bsss для идентификации

## 5. Решения по безопасности

### 5.1. Строгие режимы Bash
**Решение:** Использовать set -euo pipefail

**Обоснование:**
- Предотвращает непредвиденное поведение при ошибках
- Обеспечивает предсказуемость выполнения
- Соответствует лучшим практикам безопасности

### 5.2. Безопасная обработка переменных
**Решение:** Все переменные в двойных кавычках, локальные переменные в функциях

**Обоснование:**
- Предотвращает инъекции и разделение слов
- Избегает загрязнения глобального пространства имен
- Обеспечивает предсказуемое поведение

## 6. Решения по тестируемости

### 6.1. Mock окружения для тестирования
**Решение:** Создание тестовых окружений с различными сценариями конфигураций

**Обоснование:**
- Позволяет тестировать все возможные сценарии
- Изолирует тесты от реальной системы
- Обеспечивает воспроизводимость тестов

**Сценарии тестирования:**
- Базовый сценарий (без .d директорий)
- Существующие .d директории (пустые)
- .d директории с правилами
- Конфликтующие правила

### 6.2. Разделение режимов выполнения
**Решение:** Поддержка режимов check, default, normal

**Обоснование:**
- Упрощает тестирование отдельных функций
- Позволяет безопасно проверять состояние системы
- Обеспечивает гибкость использования

## 7. Решения по расширяемости

### 7.1. Модульная архитектура
**Решение:** Каждый функциональный блок - отдельный модуль

**Обоснование:**
- Легкость добавления новых функций
- Независимая разработка и тестирование модулей
- Возможность отключения ненужных функций

### 7.2. Вспомогательные функции
**Решение:** Выделение общих функций в helpers

**Обоснование:**
- Уменьшение дублирования кода
- Упрощение поддержки
- Повышение надежности за счет централизованной реализации

## 8. Решения по производительности

### 8.1. Отказ от кеширования результатов
**Решение:** Не кешировать результаты проверок между шагами

**Обоснование:**
- Упрощает логику и отладку
- Избегает проблем с устаревшими данными
- Обеспечивает актуальность информации на каждом шаге

### 8.2. Минимизация внешних вызовов
**Решение:** Использовать встроенные возможности Bash там, где это возможно

**Обоснование:**
- Повышение производительности
- Снижение зависимостей от внешних утилит
- Увеличение портативности

## 9. Критические архитектурные компромиссы

### 9.1. Простота vs. Функциональность
**Компромисс:** Выбрана простота реализации в ущерб некоторой функциональности

**Примеры:**
- Простой текстовый интерфейс вместо GUI
- Отказ от сложной системы отката изменений
- Минимальное логирование без подробной статистики

### 9.2. Безопасность vs. Удобство
**Компромисс:** Приоритет безопасности над удобством использования

**Примеры:**
- Обязательные проверки прав root
- Строгая валидация ввода
- Отказ от опасных конструкций (eval)

### 9.3. Портативность vs. Оптимизация
**Компромисс:** Выбрана максимальная портативность вместо оптимизации под конкретные системы

**Примеры:**
- Использование стандартных утилит вместо специфичных
- Отказ от оптимизаций для конкретных версий Ubuntu
- Поддержка только базового набора функциональности